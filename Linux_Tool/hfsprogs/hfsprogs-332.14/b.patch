--- hfsprogs-332.14.orig/debian/lintian-override
+++ hfsprogs-332.14/debian/lintian-override
@@ -0,0 +1 @@
+hfsprogs: possible-gpl-code-linked-with-openssl
--- hfsprogs-332.14.orig/debian/control
+++ hfsprogs-332.14/debian/control
@@ -0,0 +1,34 @@
+Source: hfsprogs
+Section: otherosfs
+Priority: optional
+DM-Upload-Allowed: yes
+Maintainer: Rog矇rio Brito <rbrito@ime.usp.br>
+Homepage: http://www.opensource.apple.com/darwinsource/10.4/
+Build-Depends: debhelper (>= 5), quilt, libssl-dev, libc6-dev-i386 [amd64], ia32-libs [amd64], gcc-multilib [amd64]
+Standards-Version: 3.8.0
+
+Package: hfsprogs
+Architecture: i386 powerpc sparc arm armel armeb kfreebsd-i386 amd64 hppa mips mipsel s390 m68k
+Depends: ${shlibs:Depends}, ${misc:Depends}
+Description: mkfs and fsck for HFS and HFS+ file systems
+ The HFS+ file system used by Apple Computer for their Mac OS is
+ supported by the Linux kernel.  Apple provides mkfs and fsck for
+ HFS+ with the Unix core of their operating system, Darwin.
+ .
+ This package is a port of Apple's tools for HFS+ filesystems.
+ .
+ For users, HFS+ seems to be a good compromise to carry files between
+ MacOS X and Linux Machines, as HFS+ doesn't suffer the problems of
+ FAT32 like:
+ .
+  * huge space waste (in slack space as devices grow faster);
+  * ability to create files that are more than 4GB in size (especially
+    good for those working with multimedia and that need to carry large
+    ISO files);
+  * ability to use case preserving (and even sensitivity!);
+  * ability to use uid's and gid's on the filesystem.
+ .
+ Users in general can enjoy such benefits since it is expected to have
+ more HFS+ filesystems in use, as Apple has announced Macintoshes for
+ ix86-64, besides the filesystem being already supported by PowerPC
+ systems since the beginning.
--- hfsprogs-332.14.orig/debian/watch
+++ hfsprogs-332.14/debian/watch
@@ -0,0 +1,2 @@
+# Since Apple requires a login to download new packages, this watch
+# file is a no-op.
--- hfsprogs-332.14.orig/debian/changelog
+++ hfsprogs-332.14/debian/changelog
@@ -0,0 +1,69 @@
+hfsprogs (332.14-5) unstable; urgency=low
+
+  * debian/patches: break-up the Gentoo patch into smaller patches.
+  * debian/patches: reorder the patches.
+  * debian/patches: refresh the patches.
+  * debian/patches: remove mention of pdisk (Closes: #482868) (LP: #234749).
+  * debian/control: include Homepage field.
+  * debian/control: update Standards-Version to 3.8.0. No changes required.
+  * debian/control: include DM-Upload-Allowed, as I am a DM now.
+  * debian/control: remove statement about using journals (LP: #164151).
+  * debian/rules: add -Wextra compilation flag.
+  * debian/rules: use quilt.make and remove home-brew solution.
+  * debian/watch: create watch file (lintian warning).
+
+ -- Rog矇rio Brito <rbrito@ime.usp.br>  Tue, 07 Oct 2008 05:08:48 -0300
+
+hfsprogs (332.14-4) unstable; urgency=low
+
+  * debian/changelog: fix typo on Adam's name.
+  * debian/control: include "amd64" as a 64 bit target architecture.
+  * debian/control: include "hppa mips mipsel s390" 32 bit target
+    architectures (Closes: #482070).
+  * debian/control: include "m68k" as another architecture.
+    (Tks: Gerfried Fuchs)
+  * debian/rules: include detection of amd64 and pass information to build
+    process. Warning: the kernel needs to have support/emulation for 32 bit
+    applications enabled. (Tks: Adam C矇cile)
+  * debian/rules: uses $(CURDIR) instead of $(PWD) as per lintian hint.
+  * debian/{lintian-override,rules}: create a lintian override for the
+    license (only the packaging is GPL, not the entire source code).
+
+ -- Rog矇rio Brito <rbrito@ime.usp.br>  Tue, 20 May 2008 18:57:18 -0300
+
+hfsprogs (332.14-3) unstable; urgency=low
+
+  * debian/control: include more 32-bit architectures as requested
+    (Closes: #469151). Despite the fact that there is already a new
+    upstream version, I plan on having it be a team-managed package.
+  * Update to new Debian Policy Standard (no changes).
+
+ -- Rog矇rio Brito <rbrito@ime.usp.br>  Thu, 08 May 2008 17:26:15 -0300
+
+hfsprogs (332.14-2) unstable; urgency=low
+
+  * debian/control: restrict the number of architectures to i386 and powerpc,
+    since the package is not 64 bit clean (compiling on amd64 with option -m32
+    is under study for a future version of the package). See for reference bug
+    #436159 which originated the discussion and for which this is a workaround
+    to be addressed properly later.
+
+ -- Rog矇rio Brito <rbrito@ime.usp.br>  Mon, 03 Dec 2007 20:06:00 -0200
+
+hfsprogs (332.14-1) unstable; urgency=low
+
+  * Initial release (Closes: #433168)
+  * debian/control: add dependency on libssl-dev for the hash functions
+  * debian/control: add dependency on quilt
+  * debian/copyright: included the complete text of the APSL 2.0
+  * debian/links: create links for HFS variants of the utils and manpages
+  * debian/rules: use quilt to patch the source, so we get a Makefile for Linux
+  * debian/patches: incorporated patch from Gentoo to work with quilt
+  * debian/patches: included patch to fix *roff warning
+  * debian/patches: added patch to install bootdata on usr/share correctly
+  * debian/patches: added patch to enable the -a for fsck (Tks: Adam C矇cile)
+  * debian/dirs: added entry for directory mentioned above
+  * debian/rules: added the file for wrapper HFS filesystem
+  * debian/README.Debian: give the URL of the Gentoo instructions
+
+ -- Rog矇rio Brito <rbrito@ime.usp.br>  Fri, 20 Jul 2007 09:37:02 -0300
--- hfsprogs-332.14.orig/debian/links
+++ hfsprogs-332.14/debian/links
@@ -0,0 +1,4 @@
+sbin/mkfs.hfsplus			sbin/mkfs.hfs
+sbin/fsck.hfsplus			sbin/fsck.hfs
+usr/share/man/man8/mkfs.hfsplus.8	usr/share/man/man8/mkfs.hfs.8
+usr/share/man/man8/fsck.hfsplus.8	usr/share/man/man8/fsck.hfs.8
--- hfsprogs-332.14.orig/debian/README.Debian
+++ hfsprogs-332.14/debian/README.Debian
@@ -0,0 +1,13 @@
+hfsprogs for Debian
+-------------------
+
+This package currently only provides mkfs.hfs (mkhfs) and fsck.hfs
+(hfsfsck).  In the future, it may provide more tools from the Darwin
+sources, such as a utility to tune a filesystem, like disabling the
+journaling of the filesystem.
+
+It includes a patch from from Gentoo, as described in their wiki:
+<http://gentoo-wiki.com/HOWTO_hfsplus>.
+
+
+ -- Rog矇rio Brito <rbrito@users.sf.net>  Mon, 16 Jul 2007 17:55:21 -0300
--- hfsprogs-332.14.orig/debian/dirs
+++ hfsprogs-332.14/debian/dirs
@@ -0,0 +1,4 @@
+sbin
+usr/share/hfsprogs
+usr/share/man/man8
+usr/share/lintian/overrides
--- hfsprogs-332.14.orig/debian/rules
+++ hfsprogs-332.14/debian/rules
@@ -0,0 +1,112 @@
+#!/usr/bin/make -f
+# -*- makefile -*-
+
+# Auxiliary variables
+pkgname=hfsprogs
+tmpdir=debian/$(pkgname)
+shrdir=$(tmpdir)/usr/share/$(pkgname)
+docdir=$(tmpdir)/usr/share/doc/$(pkgname)
+mansec=man8
+mandir=$(tmpdir)/usr/share/man/$(mansec)
+
+
+include /usr/share/quilt/quilt.make
+
+
+# CFLAGS
+CFLAGS = -Wall -Wextra -g
+
+ifneq (,$(findstring noopt,$(DEB_BUILD_OPTIONS)))
+	CFLAGS += -O0
+else
+	CFLAGS += -O2
+endif
+
+# Suggestion from Adam Cecile <gandalf@le-vert.net>
+CFLAGS += -DDEBUG_BUILD=0 -D_FILE_OFFSET_BITS=64 -D LINUX=1 -D BSD=1 -I$(CURDIR)/include
+CFLAGSFSCK = $(CFLAGS)
+LDFLAGSFSCK = $(LDFLAGS)
+
+# For compiling on amd64
+DEB_HOST_ARCH	?= $(shell dpkg-architecture -qDEB_HOST_ARCH)
+ifneq (,$(findstring amd64,$(DEB_HOST_ARCH)))
+	CFLAGSFSCK += -m32
+	LDFLAGSFSCK += -m32
+endif
+
+configure: configure-stamp
+configure-stamp: $(QUILT_STAMPFN)
+	dh_testdir
+
+	# Add here commands to configure the package.
+	#ln -sf debian/patches
+	#quilt push -a || test $$? = 2
+
+	touch configure-stamp
+
+build: build-stamp
+
+build-stamp: configure-stamp 
+	dh_testdir
+
+	#$(MAKE) -f Makefile.lnx
+	cd newfs_hfs.tproj/; $(MAKE) -f Makefile.lnx CFLAGS="$(CFLAGS)"
+	cd fsck_hfs.tproj/; $(MAKE) -f Makefile.lnx CFLAGS="$(CFLAGSFSCK)" LDFLAGS="$(LDFLAGSFSCK)"
+
+	touch $@
+
+clean: unpatch
+	dh_testdir
+	dh_testroot
+	rm -f build-stamp configure-stamp
+
+	#ln -sf debian/patches
+	#[ ! -f Makefile.lnx ] || $(MAKE) -f Makefile.lnx clean
+	#quilt pop -a -R || test $$? = 2
+
+	# remove quilt remains
+	#rm -f   patches
+	#rm -rf .pc
+
+	# Add here commands to clean up after the build process.
+	rm -rf newfs_hfs.tproj/*.o  newfs_hfs.tproj/newfs_hfs
+	rm -rf fsck_hfs.tproj/*.o   fsck_hfs.tproj/fsck_hfs
+	rm -rf fsck_hfs.tproj/dfalib/*.o fsck_hfs.tproj/dfalib/libdfa.a
+	dh_clean
+
+install: build
+	dh_testdir
+	dh_testroot
+	dh_clean -k 
+	dh_installdirs
+
+	# Add here commands to install the package into debian/hfsprogs.
+	install -m 644 newfs_hfs.tproj/hfsbootdata.img $(shrdir)/hfsbootdata
+	install -m 755 newfs_hfs.tproj/newfs_hfs   $(tmpdir)/sbin/mkfs.hfsplus
+	install -m 755 fsck_hfs.tproj/fsck_hfs     $(tmpdir)/sbin/fsck.hfsplus
+	install -m 644 newfs_hfs.tproj/newfs_hfs.8 $(mandir)/mkfs.hfsplus.8
+	install -m 644 fsck_hfs.tproj/fsck_hfs.8   $(mandir)/fsck.hfsplus.8
+
+# Build architecture-independent files here.
+binary-indep: build install
+
+# Build architecture-dependent files here.
+binary-arch: build install
+	dh_testdir
+	dh_testroot
+	dh_installchangelogs
+	dh_installdocs
+	dh_installman
+	dh_link
+	cp debian/lintian-override $(tmpdir)/usr/share/lintian/overrides/$(pkgname)
+	dh_strip
+	dh_compress
+	dh_fixperms
+	dh_installdeb
+	dh_shlibdeps
+	dh_gencontrol
+	dh_md5sums
+	dh_builddeb
+
+binary: binary-indep binary-arch
+.PHONY: build clean binary-indep binary-arch binary install configure
--- hfsprogs-332.14.orig/debian/copyright
+++ hfsprogs-332.14/debian/copyright
@@ -0,0 +1,387 @@
+This package was debianized by Rog矇rio Brito <rbrito@users.sf.net> on
+Mon, 16 Jul 2007 17:55:21 -0300.
+
+It was downloaded from http://www.opensource.apple.com/darwinsource/10.4/
+The patch from the Gentoo distribution was downloaded from
+http://www.ecl.udel.edu/~mcgee/diskdev_cmds/diskdev_cmds-332.14.patch.bz2
+
+Upstream Author: 
+
+    Apple Computer Inc.
+
+Copyright: 
+
+    Copyright (C) 2005,2006,2007 Apple Computer Inc.
+
+License:
+
+    APPLE PUBLIC SOURCE LICENSE
+    Version 2.0 - August 6, 2003
+    
+    Please read this License carefully before downloading this software.
+    By downloading or using this software, you are agreeing to be bound by
+    the terms of this License. If you do not or cannot agree to the terms
+    of this License, please do not download or use the software.
+    
+    1. General; Definitions. This License applies to any program or other
+    work which Apple Computer, Inc. ("Apple") makes publicly available and
+    which contains a notice placed by Apple identifying such program or
+    work as "Original Code" and stating that it is subject to the terms of
+    this Apple Public Source License version 2.0 ("License"). As used in
+    this License:
+    
+    1.1 "Applicable Patent Rights" mean: (a) in the case where Apple is
+    the grantor of rights, (i) claims of patents that are now or hereafter
+    acquired, owned by or assigned to Apple and (ii) that cover subject
+    matter contained in the Original Code, but only to the extent
+    necessary to use, reproduce and/or distribute the Original Code
+    without infringement; and (b) in the case where You are the grantor of
+    rights, (i) claims of patents that are now or hereafter acquired,
+    owned by or assigned to You and (ii) that cover subject matter in Your
+    Modifications, taken alone or in combination with Original Code.
+    
+    1.2 "Contributor" means any person or entity that creates or
+    contributes to the creation of Modifications.
+    
+    1.3 "Covered Code" means the Original Code, Modifications, the
+    combination of Original Code and any Modifications, and/or any
+    respective portions thereof.
+    
+    1.4 "Externally Deploy" means: (a) to sublicense, distribute or
+    otherwise make Covered Code available, directly or indirectly, to
+    anyone other than You; and/or (b) to use Covered Code, alone or as
+    part of a Larger Work, in any way to provide a service, including but
+    not limited to delivery of content, through electronic communication
+    with a client other than You.
+    
+    1.5 "Larger Work" means a work which combines Covered Code or portions
+    thereof with code not governed by the terms of this License.
+    
+    1.6 "Modifications" mean any addition to, deletion from, and/or change
+    to, the substance and/or structure of the Original Code, any previous
+    Modifications, the combination of Original Code and any previous
+    Modifications, and/or any respective portions thereof. When code is
+    released as a series of files, a Modification is: (a) any addition to
+    or deletion from the contents of a file containing Covered Code;
+    and/or (b) any new file or other representation of computer program
+    statements that contains any part of Covered Code.
+    
+    1.7 "Original Code" means (a) the Source Code of a program or other
+    work as originally made available by Apple under this License,
+    including the Source Code of any updates or upgrades to such programs
+    or works made available by Apple under this License, and that has been
+    expressly identified by Apple as such in the header file(s) of such
+    work; and (b) the object code compiled from such Source Code and
+    originally made available by Apple under this License.
+    
+    1.8 "Source Code" means the human readable form of a program or other
+    work that is suitable for making modifications to it, including all
+    modules it contains, plus any associated interface definition files,
+    scripts used to control compilation and installation of an executable
+    (object code).
+    
+    1.9 "You" or "Your" means an individual or a legal entity exercising
+    rights under this License. For legal entities, "You" or "Your"
+    includes any entity which controls, is controlled by, or is under
+    common control with, You, where "control" means (a) the power, direct
+    or indirect, to cause the direction or management of such entity,
+    whether by contract or otherwise, or (b) ownership of fifty percent
+    (50%) or more of the outstanding shares or beneficial ownership of
+    such entity.
+    
+    2. Permitted Uses; Conditions & Restrictions. Subject to the terms
+    and conditions of this License, Apple hereby grants You, effective on
+    the date You accept this License and download the Original Code, a
+    world-wide, royalty-free, non-exclusive license, to the extent of
+    Apple's Applicable Patent Rights and copyrights covering the Original
+    Code, to do the following:
+    
+    2.1 Unmodified Code. You may use, reproduce, display, perform,
+    internally distribute within Your organization, and Externally Deploy
+    verbatim, unmodified copies of the Original Code, for commercial or
+    non-commercial purposes, provided that in each instance:
+    
+    (a) You must retain and reproduce in all copies of Original Code the
+    copyright and other proprietary notices and disclaimers of Apple as
+    they appear in the Original Code, and keep intact all notices in the
+    Original Code that refer to this License; and
+    
+    (b) You must include a copy of this License with every copy of Source
+    Code of Covered Code and documentation You distribute or Externally
+    Deploy, and You may not offer or impose any terms on such Source Code
+    that alter or restrict this License or the recipients' rights
+    hereunder, except as permitted under Section 6.
+    
+    2.2 Modified Code. You may modify Covered Code and use, reproduce,
+    display, perform, internally distribute within Your organization, and
+    Externally Deploy Your Modifications and Covered Code, for commercial
+    or non-commercial purposes, provided that in each instance You also
+    meet all of these conditions:
+    
+    (a) You must satisfy all the conditions of Section 2.1 with respect to
+    the Source Code of the Covered Code;
+    
+    (b) You must duplicate, to the extent it does not already exist, the
+    notice in Exhibit A in each file of the Source Code of all Your
+    Modifications, and cause the modified files to carry prominent notices
+    stating that You changed the files and the date of any change; and
+    
+    (c) If You Externally Deploy Your Modifications, You must make
+    Source Code of all Your Externally Deployed Modifications either
+    available to those to whom You have Externally Deployed Your
+    Modifications, or publicly available. Source Code of Your Externally
+    Deployed Modifications must be released under the terms set forth in
+    this License, including the license grants set forth in Section 3
+    below, for as long as you Externally Deploy the Covered Code or twelve
+    (12) months from the date of initial External Deployment, whichever is
+    longer. You should preferably distribute the Source Code of Your
+    Externally Deployed Modifications electronically (e.g. download from a
+    web site).
+    
+    2.3 Distribution of Executable Versions. In addition, if You
+    Externally Deploy Covered Code (Original Code and/or Modifications) in
+    object code, executable form only, You must include a prominent
+    notice, in the code itself as well as in related documentation,
+    stating that Source Code of the Covered Code is available under the
+    terms of this License with information on how and where to obtain such
+    Source Code.
+    
+    2.4 Third Party Rights. You expressly acknowledge and agree that
+    although Apple and each Contributor grants the licenses to their
+    respective portions of the Covered Code set forth herein, no
+    assurances are provided by Apple or any Contributor that the Covered
+    Code does not infringe the patent or other intellectual property
+    rights of any other entity. Apple and each Contributor disclaim any
+    liability to You for claims brought by any other entity based on
+    infringement of intellectual property rights or otherwise. As a
+    condition to exercising the rights and licenses granted hereunder, You
+    hereby assume sole responsibility to secure any other intellectual
+    property rights needed, if any. For example, if a third party patent
+    license is required to allow You to distribute the Covered Code, it is
+    Your responsibility to acquire that license before distributing the
+    Covered Code.
+    
+    3. Your Grants. In consideration of, and as a condition to, the
+    licenses granted to You under this License, You hereby grant to any
+    person or entity receiving or distributing Covered Code under this
+    License a non-exclusive, royalty-free, perpetual, irrevocable license,
+    under Your Applicable Patent Rights and other intellectual property
+    rights (other than patent) owned or controlled by You, to use,
+    reproduce, display, perform, modify, sublicense, distribute and
+    Externally Deploy Your Modifications of the same scope and extent as
+    Apple's licenses under Sections 2.1 and 2.2 above.
+    
+    4. Larger Works. You may create a Larger Work by combining Covered
+    Code with other code not governed by the terms of this License and
+    distribute the Larger Work as a single product. In each such instance,
+    You must make sure the requirements of this License are fulfilled for
+    the Covered Code or any portion thereof.
+    
+    5. Limitations on Patent License. Except as expressly stated in
+    Section 2, no other patent rights, express or implied, are granted by
+    Apple herein. Modifications and/or Larger Works may require additional
+    patent licenses from Apple which Apple may grant in its sole
+    discretion.
+    
+    6. Additional Terms. You may choose to offer, and to charge a fee for,
+    warranty, support, indemnity or liability obligations and/or other
+    rights consistent with the scope of the license granted herein
+    ("Additional Terms") to one or more recipients of Covered Code.
+    However, You may do so only on Your own behalf and as Your sole
+    responsibility, and not on behalf of Apple or any Contributor. You
+    must obtain the recipient's agreement that any such Additional Terms
+    are offered by You alone, and You hereby agree to indemnify, defend
+    and hold Apple and every Contributor harmless for any liability
+    incurred by or claims asserted against Apple or such Contributor by
+    reason of any such Additional Terms.
+    
+    7. Versions of the License. Apple may publish revised and/or new
+    versions of this License from time to time. Each version will be given
+    a distinguishing version number. Once Original Code has been published
+    under a particular version of this License, You may continue to use it
+    under the terms of that version. You may also choose to use such
+    Original Code under the terms of any subsequent version of this
+    License published by Apple. No one other than Apple has the right to
+    modify the terms applicable to Covered Code created under this
+    License.
+    
+    8. NO WARRANTY OR SUPPORT. The Covered Code may contain in whole or in
+    part pre-release, untested, or not fully tested works. The Covered
+    Code may contain errors that could cause failures or loss of data, and
+    may be incomplete or contain inaccuracies. You expressly acknowledge
+    and agree that use of the Covered Code, or any portion thereof, is at
+    Your sole and entire risk. THE COVERED CODE IS PROVIDED "AS IS" AND
+    WITHOUT WARRANTY, UPGRADES OR SUPPORT OF ANY KIND AND APPLE AND
+    APPLE'S LICENSOR(S) (COLLECTIVELY REFERRED TO AS "APPLE" FOR THE
+    PURPOSES OF SECTIONS 8 AND 9) AND ALL CONTRIBUTORS EXPRESSLY DISCLAIM
+    ALL WARRANTIES AND/OR CONDITIONS, EXPRESS OR IMPLIED, INCLUDING, BUT
+    NOT LIMITED TO, THE IMPLIED WARRANTIES AND/OR CONDITIONS OF
+    MERCHANTABILITY, OF SATISFACTORY QUALITY, OF FITNESS FOR A PARTICULAR
+    PURPOSE, OF ACCURACY, OF QUIET ENJOYMENT, AND NONINFRINGEMENT OF THIRD
+    PARTY RIGHTS. APPLE AND EACH CONTRIBUTOR DOES NOT WARRANT AGAINST
+    INTERFERENCE WITH YOUR ENJOYMENT OF THE COVERED CODE, THAT THE
+    FUNCTIONS CONTAINED IN THE COVERED CODE WILL MEET YOUR REQUIREMENTS,
+    THAT THE OPERATION OF THE COVERED CODE WILL BE UNINTERRUPTED OR
+    ERROR-FREE, OR THAT DEFECTS IN THE COVERED CODE WILL BE CORRECTED. NO
+    ORAL OR WRITTEN INFORMATION OR ADVICE GIVEN BY APPLE, AN APPLE
+    AUTHORIZED REPRESENTATIVE OR ANY CONTRIBUTOR SHALL CREATE A WARRANTY.
+    You acknowledge that the Covered Code is not intended for use in the
+    operation of nuclear facilities, aircraft navigation, communication
+    systems, or air traffic control machines in which case the failure of
+    the Covered Code could lead to death, personal injury, or severe
+    physical or environmental damage.
+    
+    9. LIMITATION OF LIABILITY. TO THE EXTENT NOT PROHIBITED BY LAW, IN NO
+    EVENT SHALL APPLE OR ANY CONTRIBUTOR BE LIABLE FOR ANY INCIDENTAL,
+    SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES ARISING OUT OF OR RELATING
+    TO THIS LICENSE OR YOUR USE OR INABILITY TO USE THE COVERED CODE, OR
+    ANY PORTION THEREOF, WHETHER UNDER A THEORY OF CONTRACT, WARRANTY,
+    TORT (INCLUDING NEGLIGENCE), PRODUCTS LIABILITY OR OTHERWISE, EVEN IF
+    APPLE OR SUCH CONTRIBUTOR HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+    DAMAGES AND NOTWITHSTANDING THE FAILURE OF ESSENTIAL PURPOSE OF ANY
+    REMEDY. SOME JURISDICTIONS DO NOT ALLOW THE LIMITATION OF LIABILITY OF
+    INCIDENTAL OR CONSEQUENTIAL DAMAGES, SO THIS LIMITATION MAY NOT APPLY
+    TO YOU. In no event shall Apple's total liability to You for all
+    damages (other than as may be required by applicable law) under this
+    License exceed the amount of fifty dollars ($50.00).
+    
+    10. Trademarks. This License does not grant any rights to use the
+    trademarks or trade names "Apple", "Apple Computer", "Mac", "Mac OS",
+    "QuickTime", "QuickTime Streaming Server" or any other trademarks,
+    service marks, logos or trade names belonging to Apple (collectively
+    "Apple Marks") or to any trademark, service mark, logo or trade name
+    belonging to any Contributor. You agree not to use any Apple Marks in
+    or as part of the name of products derived from the Original Code or
+    to endorse or promote products derived from the Original Code other
+    than as expressly permitted by and in strict compliance at all times
+    with Apple's third party trademark usage guidelines which are posted
+    at http://www.apple.com/legal/guidelinesfor3rdparties.html.
+    
+    11. Ownership. Subject to the licenses granted under this License,
+    each Contributor retains all rights, title and interest in and to any
+    Modifications made by such Contributor. Apple retains all rights,
+    title and interest in and to the Original Code and any Modifications
+    made by or on behalf of Apple ("Apple Modifications"), and such Apple
+    Modifications will not be automatically subject to this License. Apple
+    may, at its sole discretion, choose to license such Apple
+    Modifications under this License, or on different terms from those
+    contained in this License or may choose not to license them at all.
+    
+    12. Termination.
+    
+    12.1 Termination. This License and the rights granted hereunder will
+    terminate:
+    
+    (a) automatically without notice from Apple if You fail to comply with
+    any term(s) of this License and fail to cure such breach within 30
+    days of becoming aware of such breach;
+    
+    (b) immediately in the event of the circumstances described in Section
+    13.5(b); or
+    
+    (c) automatically without notice from Apple if You, at any time during
+    the term of this License, commence an action for patent infringement
+    against Apple; provided that Apple did not first commence
+    an action for patent infringement against You in that instance.
+    
+    12.2 Effect of Termination. Upon termination, You agree to immediately
+    stop any further use, reproduction, modification, sublicensing and
+    distribution of the Covered Code. All sublicenses to the Covered Code
+    which have been properly granted prior to termination shall survive
+    any termination of this License. Provisions which, by their nature,
+    should remain in effect beyond the termination of this License shall
+    survive, including but not limited to Sections 3, 5, 8, 9, 10, 11,
+    12.2 and 13. No party will be liable to any other for compensation,
+    indemnity or damages of any sort solely as a result of terminating
+    this License in accordance with its terms, and termination of this
+    License will be without prejudice to any other right or remedy of
+    any party.
+    
+    13. Miscellaneous.
+    
+    13.1 Government End Users. The Covered Code is a "commercial item" as
+    defined in FAR 2.101. Government software and technical data rights in
+    the Covered Code include only those rights customarily provided to the
+    public as defined in this License. This customary commercial license
+    in technical data and software is provided in accordance with FAR
+    12.211 (Technical Data) and 12.212 (Computer Software) and, for
+    Department of Defense purchases, DFAR 252.227-7015 (Technical Data --
+    Commercial Items) and 227.7202-3 (Rights in Commercial Computer
+    Software or Computer Software Documentation). Accordingly, all U.S.
+    Government End Users acquire Covered Code with only those rights set
+    forth herein.
+    
+    13.2 Relationship of Parties. This License will not be construed as
+    creating an agency, partnership, joint venture or any other form of
+    legal association between or among You, Apple or any Contributor, and
+    You will not represent to the contrary, whether expressly, by
+    implication, appearance or otherwise.
+    
+    13.3 Independent Development. Nothing in this License will impair
+    Apple's right to acquire, license, develop, have others develop for
+    it, market and/or distribute technology or products that perform the
+    same or similar functions as, or otherwise compete with,
+    Modifications, Larger Works, technology or products that You may
+    develop, produce, market or distribute.
+    
+    13.4 Waiver; Construction. Failure by Apple or any Contributor to
+    enforce any provision of this License will not be deemed a waiver of
+    future enforcement of that or any other provision. Any law or
+    regulation which provides that the language of a contract shall be
+    construed against the drafter will not apply to this License.
+    
+    13.5 Severability. (a) If for any reason a court of competent
+    jurisdiction finds any provision of this License, or portion thereof,
+    to be unenforceable, that provision of the License will be enforced to
+    the maximum extent permissible so as to effect the economic benefits
+    and intent of the parties, and the remainder of this License will
+    continue in full force and effect. (b) Notwithstanding the foregoing,
+    if applicable law prohibits or restricts You from fully and/or
+    specifically complying with Sections 2 and/or 3 or prevents the
+    enforceability of either of those Sections, this License will
+    immediately terminate and You must immediately discontinue any use of
+    the Covered Code and destroy all copies of it that are in your
+    possession or control.
+    
+    13.6 Dispute Resolution. Any litigation or other dispute resolution
+    between You and Apple relating to this License shall take place in the
+    Northern District of California, and You and Apple hereby consent to
+    the personal jurisdiction of, and venue in, the state and federal
+    courts within that District with respect to this License. The
+    application of the United Nations Convention on Contracts for the
+    International Sale of Goods is expressly excluded.
+    
+    13.7 Entire Agreement; Governing Law. This License constitutes the
+    entire agreement between the parties with respect to the subject
+    matter hereof. This License shall be governed by the laws of the
+    United States and the State of California, except that body of
+    California law concerning conflicts of law.
+    
+    Where You are located in the province of Quebec, Canada, the following
+    clause applies: The parties hereby confirm that they have requested
+    that this License and all related documents be drafted in English. Les
+    parties ont exige que le present contrat et tous les documents
+    connexes soient rediges en anglais.
+    
+    EXHIBIT A.
+    
+    "Portions Copyright (c) 1999-2003 Apple Computer, Inc. All Rights
+    Reserved.
+    
+    This file contains Original Code and/or Modifications of Original Code
+    as defined in and that are subject to the Apple Public Source License
+    Version 2.0 (the 'License'). You may not use this file except in
+    compliance with the License. Please obtain a copy of the License at
+    http://www.opensource.apple.com/apsl/ and read it before using this
+    file.
+    
+    The Original Code and all software distributed under the License are
+    distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
+    EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
+    INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
+    FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
+    Please see the License for the specific language governing rights and
+    limitations under the License."
+
+The Debian packaging is (C) 2007, Rog矇rio Brito <rbrito@users.sf.net> and
+is licensed under the GPL, see `/usr/share/common-licenses/GPL'.
--- hfsprogs-332.14.orig/debian/compat
+++ hfsprogs-332.14/debian/compat
@@ -0,0 +1 @@
+5
--- hfsprogs-332.14.orig/debian/patches/10-linux_specific_code.patch
+++ hfsprogs-332.14/debian/patches/10-linux_specific_code.patch
@@ -0,0 +1,1566 @@
+Index: hfsprogs-332.14/fsck_hfs.tproj/cache.c
+===================================================================
+--- hfsprogs-332.14.orig/fsck_hfs.tproj/cache.c	2008-10-07 05:08:02.000000000 -0300
++++ hfsprogs-332.14/fsck_hfs.tproj/cache.c	2008-10-07 05:08:08.000000000 -0300
+@@ -26,7 +26,11 @@
+ #include <stdlib.h>
+ #include <sys/mman.h>
+ #include <sys/stat.h>
++#if LINUX
++#include "missing.h"
++#else
+ #include <sys/types.h>
++#endif /* __LINUX__ */
+ #include <sys/uio.h>
+ #include <unistd.h>
+ #include <string.h>
+Index: hfsprogs-332.14/fsck_hfs.tproj/dfalib/BTree.c
+===================================================================
+--- hfsprogs-332.14.orig/fsck_hfs.tproj/dfalib/BTree.c	2008-10-07 05:08:02.000000000 -0300
++++ hfsprogs-332.14/fsck_hfs.tproj/dfalib/BTree.c	2008-10-07 05:08:08.000000000 -0300
+@@ -1705,7 +1705,9 @@
+ 								 UInt16					 version,
+ 								 BTreeInfoRec			*info )
+ {
++#if !LINUX
+ #pragma unused (version)
++#endif
+ 
+ 	BTreeControlBlockPtr	btreePtr;
+ 
+Index: hfsprogs-332.14/fsck_hfs.tproj/dfalib/BlockCache.c
+===================================================================
+--- hfsprogs-332.14.orig/fsck_hfs.tproj/dfalib/BlockCache.c	2008-10-07 05:08:02.000000000 -0300
++++ hfsprogs-332.14/fsck_hfs.tproj/dfalib/BlockCache.c	2008-10-07 05:08:08.000000000 -0300
+@@ -20,6 +20,9 @@
+  * @APPLE_LICENSE_HEADER_END@
+  */
+ 
++#if LINUX
++#include "missing.h"
++#endif
+ #include "SRuntime.h"
+ #include "Scavenger.h"
+ #include "../cache.h"
+Index: hfsprogs-332.14/fsck_hfs.tproj/dfalib/SBTree.c
+===================================================================
+--- hfsprogs-332.14.orig/fsck_hfs.tproj/dfalib/SBTree.c	2008-10-07 05:08:02.000000000 -0300
++++ hfsprogs-332.14/fsck_hfs.tproj/dfalib/SBTree.c	2008-10-07 05:08:08.000000000 -0300
+@@ -301,7 +301,9 @@
+ OSStatus
+ SetEndOfForkProc ( SFCB *filePtr, FSSize minEOF, FSSize maxEOF )
+ {
++#if !LINUX
+ #pragma unused (maxEOF)
++#endif
+ 
+ 	OSStatus	result;
+ 	UInt32		actualSectorsAdded;
+Index: hfsprogs-332.14/fsck_hfs.tproj/dfalib/SDevice.c
+===================================================================
+--- hfsprogs-332.14.orig/fsck_hfs.tproj/dfalib/SDevice.c	2008-10-07 05:08:02.000000000 -0300
++++ hfsprogs-332.14/fsck_hfs.tproj/dfalib/SDevice.c	2008-10-07 05:08:08.000000000 -0300
+@@ -2,7 +2,7 @@
+  * Copyright (c) 1999 Apple Computer, Inc. All rights reserved.
+  *
+  * @APPLE_LICENSE_HEADER_START@
+- * 
++ *
+  * "Portions Copyright (c) 1999 Apple Computer, Inc.  All Rights
+  * Reserved.  This file contains Original Code and/or Modifications of
+  * Original Code as defined in and that are subject to the Apple Public
+@@ -10,7 +10,7 @@
+  * except in compliance with the License.  Please obtain a copy of the
+  * License at http://www.apple.com/publicsource and read it before using
+  * this file.
+- * 
++ *
+  * The Original Code and all software distributed under the License are
+  * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
+  * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
+@@ -18,7 +18,7 @@
+  * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
+  * License for the specific language governing rights and limitations
+  * under the License."
+- * 
++ *
+  * @APPLE_LICENSE_HEADER_END@
+  */
+ #include "SRuntime.h"
+@@ -28,33 +28,71 @@
+ #include <unistd.h>
+ #include <errno.h>
+ #include <sys/ioctl.h>
+-
++#if LINUX
++#include <fcntl.h>
++#include <sys/stat.h>
++#else
+ #include <IOKit/storage/IOMediaBSDClient.h>
+-
++#endif /* LINUX */
+ #else
+-
+ #include <Files.h>
+ #include <Device.h>
+ #include <Disks.h>
+ 
+ #endif
+ 
+-
+ OSErr GetDeviceSize(int driveRefNum, UInt64 *numBlocks, UInt32 *blockSize)
+ {
+ #if BSD
+ 	UInt64 devBlockCount = 0;
+ 	int devBlockSize = 0;
++#if LINUX
++	struct stat stbuf;
++
++	devBlockSize = 512;
+ 
++#ifndef BLKGETSIZE
++#define BLKGETSIZE              _IO(0x12,96)
++#endif
++#ifndef BLKGETSIZE64
++#define BLKGETSIZE64            _IOR(0x12,114,size_t)
++#endif
++	if (fstat(driveRefNum, &stbuf) < 0){
++		printf("Error: %s\n", strerror(errno));
++		return(-1);
++	}
++
++        if (S_ISREG(stbuf.st_mode)) {
++                devBlockCount = stbuf.st_size / 512;
++        }
++        else if (S_ISBLK(stbuf.st_mode)) {
++                unsigned long size;
++                u_int64_t size64;
++                if (!ioctl(driveRefNum, BLKGETSIZE64, &size64))
++                        devBlockCount = size64 / 512;
++                else if (!ioctl(driveRefNum, BLKGETSIZE, &size))
++                        devBlockCount = size;
++                else{
++                        printf("Error: %s\n", strerror(errno));
++			return(-1);
++		}
++
++        }
++        else{
++                printf("Device is not a block device");
++		return(-1);
++	}
++#elif BSD
+ 	if (ioctl(driveRefNum, DKIOCGETBLOCKCOUNT, &devBlockCount) < 0) {
+ 		printf("ioctl(DKIOCGETBLOCKCOUNT) for fd %d: %s\n", driveRefNum, strerror(errno));
+ 		return (-1);
+ 	}
+-	
++
+ 	if (ioctl(driveRefNum, DKIOCGETBLOCKSIZE, &devBlockSize) < 0) {
+ 		printf("ioctl(DKIOCGETBLOCKSIZE) for fd %d: %s\n", driveRefNum, strerror(errno));
+ 		return (-1);
+ 	}
++#endif /* BSD */
+ 
+ 	if (devBlockSize != 512) {
+ 		*numBlocks = (devBlockCount * (UInt64)devBlockSize) / 512;
+@@ -70,24 +108,24 @@
+ 	{
+ 		/* return format list status code */
+ 		kFmtLstCode = 6,
+-		
++
+ 		/* reference number of .SONY driver */
+ 		kSonyRefNum = 0xfffb,
+-		
++
+ 		/* values returned by DriveStatus in DrvSts.twoSideFmt */
+ 		kSingleSided = 0,
+ 		kDoubleSided = -1,
+ 		kSingleSidedSize = 800,		/* 400K */
+ 		kDoubleSidedSize = 1600,	/* 800K */
+-		
++
+ 		/* values in DrvQEl.qType */
+ 		kWordDrvSiz = 0,
+ 		kLongDrvSiz = 1,
+-		
++
+ 		/* more than enough formatListRecords */
+ 		kMaxFormatListRecs = 16
+ 	};
+-	
++
+ 	ParamBlockRec	pb;
+ 	FormatListRec	formatListRecords[kMaxFormatListRecs];
+ 	DrvSts			status;
+@@ -95,22 +133,22 @@
+ 	OSErr			result;
+ 	unsigned long	blocks			= 0;
+ 
+-	
++
+ 	/* Attempt to get the drive's format list. */
+ 	/* (see the Technical Note "What Your Sony Drives For You") */
+-	
++
+ 	pb.cntrlParam.ioVRefNum = driveQElementPtr->dQDrive;
+ 	pb.cntrlParam.ioCRefNum = driveQElementPtr->dQRefNum;
+ 	pb.cntrlParam.csCode = kFmtLstCode;
+ 	pb.cntrlParam.csParam[0] = kMaxFormatListRecs;
+ 	*(long *)&pb.cntrlParam.csParam[1] = (long)&formatListRecords[0];
+-	
++
+ 	result = PBStatusSync(&pb);
+-	
++
+ 	if ( result == noErr )
+ 	{
+ 		/* The drive supports ReturnFormatList status call. */
+-		
++
+ 		/* Get the current disk's size. */
+ 		for( formatListRecIndex = 0;
+ 			 formatListRecIndex < pb.cntrlParam.csParam[0];
+@@ -131,7 +169,7 @@
+ 	else if ( driveQElementPtr->dQRefNum == (short)kSonyRefNum )
+ 	{
+ 		/* The drive is a non-SuperDrive floppy which only supports 400K and 800K disks */
+-		
++
+ 		result = DriveStatus(driveQElementPtr->dQDrive, &status);
+ 		if ( result == noErr )
+ 		{
+@@ -140,11 +178,11 @@
+ 				case kSingleSided:
+ 					blocks = kSingleSidedSize;
+ 					break;
+-					
++
+ 				case kDoubleSided:
+ 					blocks = kDoubleSidedSize;
+ 					break;
+-					
++
+ 				default:		//	This should never happen
+ 					result = paramErr;
+ 					break;
+@@ -155,20 +193,20 @@
+ 	{
+ 		/* The drive is not a floppy and it doesn't support ReturnFormatList */
+ 		/* so use the dQDrvSz field(s) */
+-		
++
+ 		result = noErr;	/* reset result */
+-		
++
+ 		switch ( driveQElementPtr->qType )
+ 		{
+ 			case kWordDrvSiz:
+ 				blocks = driveQElementPtr->dQDrvSz;
+ 				break;
+-				
++
+ 			case kLongDrvSiz:
+ 				blocks = ((unsigned long)driveQElementPtr->dQDrvSz2 << 16) +
+ 						 driveQElementPtr->dQDrvSz;
+ 				break;
+-				
++
+ 			default:		//	This should never happen
+ 				result = paramErr;
+ 				break;
+@@ -177,7 +215,7 @@
+ 
+ 	*numBlocks = blocks;
+ 	*blockSize = 512;
+-	
++
+ 	return( result );
+ #endif
+ }
+@@ -188,7 +226,7 @@
+ #if BSD
+ 	off_t seek_off;
+ 	ssize_t	nbytes;
+-	
++
+ 	*actBytes = 0;
+ 
+ 	seek_off = lseek(device, offset, SEEK_SET);
+Index: hfsprogs-332.14/fsck_hfs.tproj/dfalib/SKeyCompare.c
+===================================================================
+--- hfsprogs-332.14.orig/fsck_hfs.tproj/dfalib/SKeyCompare.c	2008-10-07 05:08:02.000000000 -0300
++++ hfsprogs-332.14/fsck_hfs.tproj/dfalib/SKeyCompare.c	2008-10-07 05:08:08.000000000 -0300
+@@ -454,7 +454,9 @@
+  * The name portion of the key is compared using a 16-bit binary comparison. 
+  * This is called from the b-tree code.
+  */
++#if !LINUX
+ __private_extern__
++#endif
+ SInt32
+ CompareAttributeKeys(const AttributeKey *searchKey, const AttributeKey *trialKey)
+ {
+Index: hfsprogs-332.14/fsck_hfs.tproj/dfalib/SRepair.c
+===================================================================
+--- hfsprogs-332.14.orig/fsck_hfs.tproj/dfalib/SRepair.c	2008-10-07 05:08:02.000000000 -0300
++++ hfsprogs-332.14/fsck_hfs.tproj/dfalib/SRepair.c	2008-10-07 05:08:08.000000000 -0300
+@@ -1593,7 +1593,9 @@
+ 
+ static	OSErr	FixWrapperExtents( SGlobPtr GPtr, RepairOrderPtr p )
+ {
++#if !LINUX
+ #pragma unused (p)
++#endif
+ 
+ 	OSErr						err;
+ 	HFSMasterDirectoryBlock		*mdb;
+Index: hfsprogs-332.14/fsck_hfs.tproj/dfalib/SRuntime.h
+===================================================================
+--- hfsprogs-332.14.orig/fsck_hfs.tproj/dfalib/SRuntime.h	2008-10-07 05:08:02.000000000 -0300
++++ hfsprogs-332.14/fsck_hfs.tproj/dfalib/SRuntime.h	2008-10-07 05:08:08.000000000 -0300
+@@ -27,8 +27,11 @@
+ #define __SRUNTIME__
+ 
+ #if BSD
+-
++#if LINUX
++#include "missing.h"
++#else
+ #include <sys/types.h>
++#endif
+ #include <stdlib.h>
+ #include <string.h>
+ #include <stdio.h>
+@@ -91,10 +94,12 @@
+ 
+ typedef u_int32_t	HFSCatalogNodeID;
+ 
++#if !LINUX
+ enum {
+ 	false		= 0,
+ 	true		= 1
+ };
++#endif
+ 
+ /* OS error codes */
+ enum {
+Index: hfsprogs-332.14/fsck_hfs.tproj/dfalib/SUtils.c
+===================================================================
+--- hfsprogs-332.14.orig/fsck_hfs.tproj/dfalib/SUtils.c	2008-10-07 05:08:02.000000000 -0300
++++ hfsprogs-332.14/fsck_hfs.tproj/dfalib/SUtils.c	2008-10-07 05:08:08.000000000 -0300
+@@ -380,7 +380,8 @@
+ //				GPtr->realVCB			Real in-memory vcb
+ //------------------------------------------------------------------------------
+ 
+-#if !BSD	
++#if BSD
++#if !LINUX
+ OSErr GetVolumeFeatures( SGlobPtr GPtr )
+ {
+ 	OSErr					err;
+@@ -418,7 +419,7 @@
+ 	return( noErr );
+ }
+ #endif
+-
++#endif
+ 
+ 
+ /*-------------------------------------------------------------------------------
+Index: hfsprogs-332.14/fsck_hfs.tproj/dfalib/SVerify2.c
+===================================================================
+--- hfsprogs-332.14.orig/fsck_hfs.tproj/dfalib/SVerify2.c	2008-10-07 05:08:02.000000000 -0300
++++ hfsprogs-332.14/fsck_hfs.tproj/dfalib/SVerify2.c	2008-10-07 05:08:08.000000000 -0300
+@@ -32,7 +32,9 @@
+ */
+ 
+ #include <sys/ioctl.h>
++#if !LINUX
+ #include <sys/disk.h>
++#endif
+ 
+ #include "BTree.h"
+ #include "BTreePrivate.h"
+@@ -1240,8 +1242,13 @@
+ 	 * clump size for read-only media is irrelevant we skip the clump size 
+ 	 * check to avoid non useful warnings. 
+ 	 */
++#if LINUX
++	// FIXME
++	isWriteable = 1;
++#else
+ 	isWriteable = 0;
+ 	ioctl( GPtr->DrvNum, DKIOCISWRITABLE, &isWriteable );
++#endif
+ 	if ( isWriteable != 0 && 
+ 		 volumeHeader->catalogFile.clumpSize != vcb->vcbCatalogFile->fcbClumpSize ) {
+ 		PrintError(GPtr, E_InvalidClumpSize, 0);
+Index: hfsprogs-332.14/fsck_hfs.tproj/dfalib/Scavenger.h
+===================================================================
+--- hfsprogs-332.14.orig/fsck_hfs.tproj/dfalib/Scavenger.h	2008-10-07 05:08:02.000000000 -0300
++++ hfsprogs-332.14/fsck_hfs.tproj/dfalib/Scavenger.h	2008-10-07 05:08:08.000000000 -0300
+@@ -35,11 +35,16 @@
+ #include "BTreeScanner.h"
+ #include "hfs_endian.h"
+ 
++#if LINUX
++#define XATTR_MAXNAMELEN 127
++#include <limits.h>
++#else
+ #include <sys/xattr.h>
+ #include <sys/acl.h>
+ #include <sys/kauth.h>
+-#include <sys/errno.h>
+ #include <sys/syslimits.h>
++#endif
++#include <sys/errno.h>
+ 
+ #ifdef __cplusplus
+ extern	"C" {
+@@ -1434,4 +1439,8 @@
+ };
+ #endif
+ 
++#if LINUX
++#undef XATTR_MAXNAMELEN
++#endif
++
+ #endif /* __SCAVENGER__ */
+Index: hfsprogs-332.14/fsck_hfs.tproj/dfalib/hfs_endian.c
+===================================================================
+--- hfsprogs-332.14.orig/fsck_hfs.tproj/dfalib/hfs_endian.c	2008-10-07 05:08:02.000000000 -0300
++++ hfsprogs-332.14/fsck_hfs.tproj/dfalib/hfs_endian.c	2008-10-07 05:08:08.000000000 -0300
+@@ -31,7 +31,11 @@
+ #include <sys/types.h>
+ #include <sys/stat.h>
+ 
++#if LINUX
++#include "missing.h"
++#else
+ #include <architecture/byte_order.h>
++#endif
+ #include <hfs/hfs_format.h>
+ 
+ #include "Scavenger.h"
+Index: hfsprogs-332.14/fsck_hfs.tproj/dfalib/hfs_endian.h
+===================================================================
+--- hfsprogs-332.14.orig/fsck_hfs.tproj/dfalib/hfs_endian.h	2008-10-07 05:08:02.000000000 -0300
++++ hfsprogs-332.14/fsck_hfs.tproj/dfalib/hfs_endian.h	2008-10-07 05:08:08.000000000 -0300
+@@ -27,9 +27,14 @@
+  *
+  * This file prototypes endian swapping routines for the HFS/HFS Plus
+  * volume format.
+- */
++*/
+ #include <hfs/hfs_format.h>
++#if LINUX
++#include <endian.h>
++#include <byteswap.h>
++#else
+ #include <architecture/byte_order.h>
++#endif
+ #include "SRuntime.h"
+ 
+ /*********************/
+Index: hfsprogs-332.14/fsck_hfs.tproj/fsck_hfs.c
+===================================================================
+--- hfsprogs-332.14.orig/fsck_hfs.tproj/fsck_hfs.c	2008-10-07 05:08:02.000000000 -0300
++++ hfsprogs-332.14/fsck_hfs.tproj/fsck_hfs.c	2008-10-07 05:08:08.000000000 -0300
+@@ -2,7 +2,7 @@
+  * Copyright (c) 1999 Apple Computer, Inc. All rights reserved.
+  *
+  * @APPLE_LICENSE_HEADER_START@
+- * 
++ *
+  * "Portions Copyright (c) 1999 Apple Computer, Inc.  All Rights
+  * Reserved.  This file contains Original Code and/or Modifications of
+  * Original Code as defined in and that are subject to the Apple Public
+@@ -10,7 +10,7 @@
+  * except in compliance with the License.  Please obtain a copy of the
+  * License at http://www.apple.com/publicsource and read it before using
+  * this file.
+- * 
++ *
+  * The Original Code and all software distributed under the License are
+  * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
+  * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
+@@ -18,16 +18,20 @@
+  * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
+  * License for the specific language governing rights and limitations
+  * under the License."
+- * 
++ *
+  * @APPLE_LICENSE_HEADER_END@
+  */
+ #include <sys/types.h>
+ #include <sys/stat.h>
+ #include <sys/param.h>
++#if !LINUX
+ #include <sys/ucred.h>
++#endif
+ #include <sys/mount.h>
+ #include <sys/ioctl.h>
++#if !LINUX
+ #include <sys/disk.h>
++#endif
+ 
+ #include <hfs/hfs_mount.h>
+ 
+@@ -125,7 +129,7 @@
+ 			yflag = 0;
+ 			force++;
+ 			break;
+-			
++
+ 		case 'm':
+ 			modeSetting++;
+ 			lostAndFoundMode = strtol( optarg, NULL, 8 );
+@@ -135,7 +139,7 @@
+ 				usage();
+ 			}
+ 			break;
+-			
++
+ 		case 'n':
+ 			nflag++;
+ 			yflag = 0;
+@@ -167,13 +171,15 @@
+ 
+ 	argc -= optind;
+ 	argv += optind;
+-	
++
+ 	if (guiControl)
+ 		debug = 0; /* debugging is for command line only */
+-
++#if LINUX
++// FIXME
++#else
+ 	if (signal(SIGINT, SIG_IGN) != SIG_IGN)
+ 		(void)signal(SIGINT, catch);
+-
++#endif
+ 	if (argc < 1) {
+ 		(void) fprintf(stderr, "%s: missing special-device\n", progname);
+ 		usage();
+@@ -194,7 +200,9 @@
+ 	int chkLev, repLev, logLev;
+ 	int blockDevice_fd, canWrite;
+ 	char *unraw, *mntonname;
++#if !LINUX
+ 	struct statfs *fsinfo;
++#endif
+ 	int fs_fd=-1;  // fd to the root-dir of the fs we're checking (only w/lfag == 1)
+ 
+ 	flags = 0;
+@@ -203,7 +211,9 @@
+ 	canWrite = 0;
+ 	unraw = NULL;
+ 	mntonname = NULL;
+-
++#if LINUX
++	// FIXME
++#else
+ 	if (lflag) {
+ 		result = getmntinfo(&fsinfo, MNT_NOWAIT);
+ 
+@@ -233,10 +243,10 @@
+ 		    }
+ 		}
+ 	}
+-
++#endif
+ 	if (debug && preen)
+ 		pwarn("starting\n");
+-	
++
+ 	if (setup( filesys, &blockDevice_fd, &canWrite ) == 0) {
+ 		if (preen)
+ 			pfatal("CAN'T CHECK FILE SYSTEM.");
+@@ -254,7 +264,7 @@
+ 	repLev = kMajorRepairs;
+ 	logLev = kVerboseLog;
+ 
+-	if (yflag)	
++	if (yflag)
+ 		repLev = kMajorRepairs;
+ 
+ 	if (quick) {
+@@ -274,16 +284,16 @@
+ 
+ 	if (nflag)
+ 		repLev = kNeverRepair;
+-		
++
+ 	if ( rebuildCatalogBtree ) {
+ 		chkLev = kPartialCheck;
+ 		repLev = kForceRepairs;  // this will force rebuild of catalog B-Tree file
+ 	}
+-		
++
+ 	/*
+ 	 * go check HFS volume...
+ 	 */
+-	result = CheckHFS(	fsreadfd, fswritefd, chkLev, repLev, logLev, 
++	result = CheckHFS(	fsreadfd, fswritefd, chkLev, repLev, logLev,
+ 						guiControl, lostAndFoundMode, canWrite, &fsmodified );
+ 	if (!hotroot) {
+ 		ckfini(1);
+@@ -306,6 +316,9 @@
+ 			}
+ 		}
+ 	} else {
++#if LINUX
++	// FIXME
++#else
+ 		struct statfs stfs_buf;
+ 		/*
+ 		 * Check to see if root is mounted read-write.
+@@ -315,19 +328,25 @@
+ 		else
+ 			flags = 0;
+ 		ckfini(flags & MNT_RDONLY);
++#endif
+ 	}
+ 
+ 	/* XXX free any allocated memory here */
+ 
+ 	if (hotroot && fsmodified) {
++#if !LINUX
+ 		struct hfs_mount_args args;
++#endif
+ 		/*
+ 		 * We modified the root.  Do a mount update on
+ 		 * it, unless it is read-write, so we can continue.
+ 		 */
+ 		if (!preen)
+ 			printf("\n***** FILE SYSTEM WAS MODIFIED *****\n");
+-		if (flags & MNT_RDONLY) {		
++#if LINUX
++		// FIXME
++#else
++		if (flags & MNT_RDONLY) {
+ 			bzero(&args, sizeof(args));
+ 			flags |= MNT_UPDATE | MNT_RELOAD;
+ 			if (mount("hfs", "/", flags, &args) == 0) {
+@@ -335,6 +354,7 @@
+ 				goto ExitThisRoutine;
+ 			}
+ 		}
++#endif
+ 		if (!preen)
+ 			printf("\n***** REBOOT NOW *****\n");
+ 		sync();
+@@ -343,7 +363,7 @@
+ 	}
+ 
+ 	result = (result == 0) ? 0 : EEXIT;
+-	
++
+ ExitThisRoutine:
+ 	if (lflag) {
+ 	    fcntl(fs_fd, F_THAW_FS, NULL);
+@@ -375,16 +395,18 @@
+ 	fswritefd = -1;
+ 	*blockDevice_fdPtr = -1;
+ 	*canWritePtr = 0;
+-	
++
+ 	if (stat(dev, &statb) < 0) {
+ 		printf("Can't stat %s: %s\n", dev, strerror(errno));
+ 		return (0);
+ 	}
++#if !LINUX
+ 	if ((statb.st_mode & S_IFMT) != S_IFCHR) {
+ 		pfatal("%s is not a character device", dev);
+ 		if (reply("CONTINUE") == 0)
+ 			return (0);
+ 	}
++#endif
+ 	if ((fsreadfd = open(dev, O_RDONLY)) < 0) {
+ 		printf("Can't open %s: %s\n", dev, strerror(errno));
+ 		return (0);
+@@ -393,7 +415,7 @@
+ 	/* attempt to get write access to the block device and if not check if volume is */
+ 	/* mounted read-only.  */
+ 	getWriteAccess( dev, blockDevice_fdPtr, canWritePtr );
+-	
++
+ 	if (preen == 0 && !guiControl)
+ 		printf("** %s", dev);
+ 	if (nflag || (fswritefd = open(dev, O_WRONLY)) < 0) {
+@@ -407,42 +429,50 @@
+ 		printf("\n");
+ 
+ 	/* Get device block size to initialize cache */
++#if LINUX
++	devBlockSize = 512;
++#else
+ 	if (ioctl(fsreadfd, DKIOCGETBLOCKSIZE, &devBlockSize) < 0) {
+ 		pfatal ("Can't get device block size\n");
+ 		return (0);
+ 	}
++#endif
+ 	/* Initialize the cache */
+ 	if (CacheInit (&fscache, fsreadfd, fswritefd, devBlockSize,
+ 			CACHE_IOSIZE, CACHE_BLOCKS, CACHE_HASHSIZE) != EOK) {
+ 		pfatal("Can't initialize disk cache\n");
+ 		return (0);
+-	}	
++	}
+ 
+ 	return (1);
+ }
+ 
+ 
+-// This routine will attempt to open the block device with write access for the target 
++// This routine will attempt to open the block device with write access for the target
+ // volume in order to block others from mounting the volume with write access while we
+ // check / repair it.  If we cannot get write access then we check to see if the volume
+-// has been mounted read-only.  If it is read-only then we should be OK to write to 
++// has been mounted read-only.  If it is read-only then we should be OK to write to
+ // the raw device.  Note that this does not protect use from someone upgrading the mount
+ // from read-only to read-write.
+ 
+ static void getWriteAccess( char *dev, int *blockDevice_fdPtr, int *canWritePtr )
+ {
++#if !LINUX
+ 	int					i;
+ 	int					myMountsCount;
++#endif
+ 	void *				myPtr;
+ 	char *				myCharPtr;
++#if !LINUX
+ 	struct statfs *		myBufPtr;
++#endif
+ 	void *				myNamePtr;
+ 
+ 	myPtr = NULL;
+ 	myNamePtr = malloc( strlen(dev) + 2 );
+-	if ( myNamePtr == NULL ) 
++	if ( myNamePtr == NULL )
+ 		return;
+-		
++
+ 	strcpy( (char *)myNamePtr, dev );
+ 	if ( (myCharPtr = strrchr( (char *)myNamePtr, '/' )) != 0 ) {
+ 		if ( myCharPtr[1] == 'r' ) {
+@@ -450,24 +480,25 @@
+ 			*blockDevice_fdPtr = open( (char *)myNamePtr, O_WRONLY );
+ 		}
+ 	}
+-	
++
+ 	if ( *blockDevice_fdPtr > 0 ) {
+ 		// we got write access to the block device so we can safely write to raw device
+ 		*canWritePtr = 1;
+ 		goto ExitThisRoutine;
+ 	}
+-	
+-	// get count of mounts then get the info for each 
++	// get count of mounts then get the info for each
++#if LINUX
++	// FIXME
++#else
+ 	myMountsCount = getfsstat( NULL, 0, MNT_NOWAIT );
+ 	if ( myMountsCount < 0 )
+ 		goto ExitThisRoutine;
+-
+ 	myPtr = (void *) malloc( sizeof(struct statfs) * myMountsCount );
+-	if ( myPtr == NULL ) 
++	if ( myPtr == NULL )
+ 		goto ExitThisRoutine;
+-	myMountsCount = getfsstat( 	myPtr, 
+-								(sizeof(struct statfs) * myMountsCount), 
+-								MNT_NOWAIT );
++	myMountsCount = getfsstat( 	myPtr,
++							(sizeof(struct statfs) * myMountsCount),
++							MNT_NOWAIT );
+ 	if ( myMountsCount < 0 )
+ 		goto ExitThisRoutine;
+ 
+@@ -481,17 +512,17 @@
+ 		}
+ 		myBufPtr++;
+ 	}
+-	*canWritePtr = 1;  // single user will get us here, f_mntfromname is not /dev/diskXXXX 
+-	
++#endif
++	*canWritePtr = 1;  // single user will get us here, f_mntfromname is not /dev/diskXXXX
+ ExitThisRoutine:
+ 	if ( myPtr != NULL )
+ 		free( myPtr );
+-		
++
+ 	if ( myNamePtr != NULL )
+ 		free( myNamePtr );
+-	
++
+ 	return;
+-	
++
+ } /* getWriteAccess */
+ 
+ 
+@@ -509,6 +540,6 @@
+ 	(void) fprintf(stderr, "  r = rebuild catalog btree \n");
+ 	(void) fprintf(stderr, "  u = usage \n");
+ 	(void) fprintf(stderr, "  y = assume a yes response \n");
+-	
++
+ 	exit(1);
+ }
+Index: hfsprogs-332.14/fsck_hfs.tproj/utilities.c
+===================================================================
+--- hfsprogs-332.14.orig/fsck_hfs.tproj/utilities.c	2008-10-07 05:08:02.000000000 -0300
++++ hfsprogs-332.14/fsck_hfs.tproj/utilities.c	2008-10-07 05:08:08.000000000 -0300
+@@ -183,12 +183,14 @@
+ 			printf("Can't stat %s\n", raw);
+ 			return (origname);
+ 		}
++#if !LINUX
+ 		if ((stchar.st_mode & S_IFMT) == S_IFCHR) {
+ 			return (raw);
+ 		} else {
+ 			printf("%s is not a character device\n", raw);
+ 			return (origname);
+ 		}
++#endif
+ 	} else if ((stblock.st_mode & S_IFMT) == S_IFCHR && !retried) {
+ 		newname = unrawname(newname);
+ 		retried++;
+@@ -214,7 +216,11 @@
+ 	*dp = 0;
+ 	(void)strcpy(rawbuf, name);
+ 	*dp = '/';
+-	(void)strcat(rawbuf, "/r");
++#if LINUX
++	(void)strcat(rawbuf, "/");
++#else
++	(void)strcat(rawbuf,"/r");
++#endif
+ 	(void)strcat(rawbuf, &dp[1]);
+ 
+ 	return (rawbuf);
+Index: hfsprogs-332.14/include/missing.h
+===================================================================
+--- /dev/null	1970-01-01 00:00:00.000000000 +0000
++++ hfsprogs-332.14/include/missing.h	2008-10-07 05:08:08.000000000 -0300
+@@ -0,0 +1,113 @@
++#ifndef _MISSING_H_
++#define _MISSING_H_
++
++#include <endian.h>
++#include <byteswap.h>
++#include <errno.h>
++#include <stdint.h>
++
++#define MAXBSIZE		(256 * 4096)
++
++#ifndef true
++#define true			1
++#endif
++#ifndef false
++#define false			0
++#endif
++
++/* Mac types */
++
++/* 8 Bit */
++#ifndef UInt8
++#define UInt8			uint8_t
++#endif
++#ifndef u_int8_t
++#define u_int8_t		UInt8
++#endif
++#ifndef SInt8
++#define SInt8			int8_t
++#endif
++
++/* 16 Bit */
++#ifndef UInt16
++#define UInt16			uint16_t
++#endif
++#ifndef u_int16_t
++#define u_int16_t		UInt16
++#endif
++#ifndef SInt16
++#define SInt16			int16_t
++#endif
++
++/* 32 Bit */
++#ifndef UInt32
++#define UInt32			uint32_t
++#endif
++#ifndef u_int32_t
++#define u_int32_t		UInt32
++#endif
++#ifndef SInt32
++#define SInt32			int32_t
++#endif
++
++/* 64 Bit */
++#ifndef UInt64
++#define UInt64			uint64_t
++#endif
++#ifndef u_int64_t
++#define u_int64_t		UInt64
++#endif
++#ifndef SInt64
++#define SInt64			int64_t
++#endif
++
++#define UniChar			u_int16_t
++#define Boolean			u_int8_t
++
++#define UF_NODUMP	0x00000001
++
++/* syslimits.h */
++#define NAME_MAX	255
++
++/* Byteswap stuff */
++#define NXSwapHostLongToBig(x)		cpu_to_be64(x)
++#define NXSwapBigShortToHost(x) 	be16_to_cpu(x)
++#define OSSwapBigToHostInt16(x)		be16_to_cpu(x)
++#define NXSwapBigLongToHost(x)		be32_to_cpu(x)
++#define OSSwapBigToHostInt32(x)		be32_to_cpu(x)
++#define NXSwapBigLongLongToHost(x) 	be64_to_cpu(x)
++#define OSSwapBigToHostInt64(x)		be64_to_cpu(x)
++
++#if __BYTE_ORDER == __LITTLE_ENDIAN
++/* Big Endian Swaps */
++#ifndef be16_to_cpu
++#define be16_to_cpu(x) bswap_16(x)
++#endif
++#ifndef be32_to_cpu
++#define be32_to_cpu(x) bswap_32(x)
++#endif
++#ifndef be64_to_cpu
++#define be64_to_cpu(x) bswap_64(x)
++#endif
++#ifndef cpu_to_be64
++#define cpu_to_be64(x) bswap_64(x)
++#endif
++#elif __BYTE_ORDER == __BIG_ENDIAN
++/* Big endian doesn't swap */
++#ifndef be16_to_cpu
++#define be16_to_cpu(x)	(x)
++#endif
++#ifndef be32_to_cpu
++#define be32_to_cpu(x)	(x)
++#endif
++#ifndef be64_to_cpu
++#define be64_to_cpu(x)	(x)
++#endif
++#ifndef cpu_to_be64
++#define cpu_to_be64(x) 	(x)
++#endif
++#endif
++
++#define KAUTH_FILESEC_XATTR "com.apple.system.Security"
++
++#endif
+Index: hfsprogs-332.14/newfs_hfs.tproj/hfs_endian.c
+===================================================================
+--- hfsprogs-332.14.orig/newfs_hfs.tproj/hfs_endian.c	2008-10-07 05:08:02.000000000 -0300
++++ hfsprogs-332.14/newfs_hfs.tproj/hfs_endian.c	2008-10-07 05:08:08.000000000 -0300
+@@ -30,7 +30,12 @@
+ #include <sys/types.h>
+ #include <sys/stat.h>
+ 
++#if LINUX
++#include "missing.h"
++#else
+ #include <architecture/byte_order.h>
++#endif
++
+ #include <hfs/hfs_format.h>
+ 
+ #include "hfs_endian.h"
+Index: hfsprogs-332.14/newfs_hfs.tproj/hfs_endian.h
+===================================================================
+--- hfsprogs-332.14.orig/newfs_hfs.tproj/hfs_endian.h	2008-10-07 05:08:02.000000000 -0300
++++ hfsprogs-332.14/newfs_hfs.tproj/hfs_endian.h	2008-10-07 05:08:08.000000000 -0300
+@@ -29,7 +29,12 @@
+  * volume format.
+  */
+ #include <hfs/hfs_format.h>
++#if LINUX
++#include <endian.h>
++#include <byteswap.h>
++#else
+ #include <architecture/byte_order.h>
++#endif
+ 
+ /*********************/
+ /* BIG ENDIAN Macros */
+Index: hfsprogs-332.14/newfs_hfs.tproj/makehfs.c
+===================================================================
+--- hfsprogs-332.14.orig/newfs_hfs.tproj/makehfs.c	2008-10-07 05:08:02.000000000 -0300
++++ hfsprogs-332.14/newfs_hfs.tproj/makehfs.c	2008-10-07 05:08:08.000000000 -0300
+@@ -31,10 +31,16 @@
+ #include <sys/param.h>
+ #include <sys/types.h>
+ #include <sys/time.h>
++#if LINUX
++#include <time.h>
++#include "missing.h"
++#endif
+ #include <sys/errno.h>
+ #include <sys/stat.h>
+ #include <sys/sysctl.h>
++#if !LINUX
+ #include <sys/vmmeter.h>
++#endif
+ 
+ #include <err.h>
+ #include <errno.h>
+@@ -47,13 +53,14 @@
+ 
+ #include <openssl/sha.h>
+ 
++#if !LINUX
+ #include <architecture/byte_order.h>
+ 
+ #include <CoreFoundation/CFString.h>
+ #include <CoreFoundation/CFStringEncodingExt.h>
+ 
+ extern Boolean _CFStringGetFileSystemRepresentation(CFStringRef string, UInt8 *buffer, CFIndex maxBufLen);
+-
++#endif
+ 
+ #include <hfs/hfs_format.h>
+ #include <hfs/hfs_mount.h>
+@@ -129,7 +136,9 @@
+ static void MarkBitInAllocationBuffer __P((HFSPlusVolumeHeader *header,
+ 		UInt32 allocationBlock, void* sectorBuffer, UInt32 *sector));
+ 
++#if !LINUX
+ static UInt32 GetDefaultEncoding();
++#endif
+ 
+ static UInt32 UTCToLocal __P((UInt32 utcTime));
+ 
+@@ -158,11 +167,14 @@
+ 
+ #define ROUNDUP(x, u)	(((x) % (u) == 0) ? (x) : ((x)/(u) + 1) * (u))
+ 
+-#define ENCODING_TO_BIT(e)                               \
++#if LINUX
++#define ENCODING_TO_BIT(e)       (e)
++#else
++#define ENCODING_TO_BIT(e)
+           ((e) < 48 ? (e) :                              \
+           ((e) == kCFStringEncodingMacUkrainian ? 48 :   \
+           ((e) == kCFStringEncodingMacFarsi ? 49 : 0)))
+-
++#endif
+ /*
+  * make_hfs
+  *	
+@@ -528,6 +540,7 @@
+ 	 * Map UTF-8 input into a Mac encoding.
+ 	 * On conversion errors "untitled" is used as a fallback.
+ 	 */
++#if !LINUX
+ 	{
+ 		UniChar unibuf[kHFSMaxVolumeNameChars];
+ 		CFStringRef cfstr;
+@@ -553,7 +566,11 @@
+ 		bcopy(&mdbp->drVN[1], defaults->volumeName, mdbp->drVN[0]);
+ 		defaults->volumeName[mdbp->drVN[0]] = '\0';
+ 	}
++#endif
+ 	/* Save the encoding hint in the Finder Info (field 4). */
++	mdbp->drVN[0] = strlen(defaults->volumeName);
++	bcopy(defaults->volumeName,&mdbp->drVN[1],mdbp->drVN[0]);
++
+ 	mdbp->drFndrInfo[4] = SET_HFS_TEXT_ENCODING(defaults->encodingHint);
+ 
+ 	mdbp->drWrCnt = kWriteSeqNum;
+@@ -1100,9 +1117,11 @@
+ 	UInt16					nodeSize;
+ 	SInt16					offset;
+ 	UInt32					unicodeBytes;
++#if !LINUX
+ 	UInt8 canonicalName[256];
+ 	CFStringRef cfstr;
+ 	Boolean	cfOK;
++#endif
+ 	int index = 0;
+ 
+ 	nodeSize = dp->catalogNodeSize;
+@@ -1122,7 +1141,9 @@
+ 	 * First record is always the root directory...
+ 	 */
+ 	ckp = (HFSPlusCatalogKey *)((UInt8 *)buffer + offset);
+-	
++#if LINUX
++	ConvertUTF8toUnicode(dp->volumeName, sizeof(ckp->nodeName.unicode), ckp->nodeName.unicode, &ckp->nodeName.length);
++#else
+ 	/* Use CFString functions to get a HFSPlus Canonical name */
+ 	cfstr = CFStringCreateWithCString(kCFAllocatorDefault, (char *)dp->volumeName, kCFStringEncodingUTF8);
+ 	cfOK = _CFStringGetFileSystemRepresentation(cfstr, canonicalName, sizeof(canonicalName));
+@@ -1139,6 +1160,7 @@
+ 		      dp->volumeName, kDefaultVolumeNameStr);
+ 	}
+ 	CFRelease(cfstr);
++#endif
+ 	ckp->nodeName.length = SWAP_BE16 (ckp->nodeName.length);
+ 
+ 	unicodeBytes = sizeof(UniChar) * SWAP_BE16 (ckp->nodeName.length);
+@@ -1821,15 +1843,15 @@
+ 	off_t sector;
+ 
+ 	if ((byteCount % driveInfo->sectorSize) != 0)
+-		errx(1, "WriteBuffer: byte count %ld is not sector size multiple", byteCount);
++		errx(1, "WriteBuffer: byte count %i is not sector size multiple", byteCount);
+ 
+ 	sector = driveInfo->sectorOffset + startingSector;
+ 
+ 	if (lseek(driveInfo->fd, sector * driveInfo->sectorSize, SEEK_SET) < 0)
+-		err(1, "seek (sector %qd)", sector);
++		err(1, "seek (sector %lld)", sector);
+ 
+ 	if (write(driveInfo->fd, buffer, byteCount) != byteCount)
+-		err(1, "write (sector %qd, %ld bytes)", sector, byteCount);
++		err(1, "write (sector %lld, %i bytes)", sector, byteCount);
+ }
+ 
+ 
+@@ -1913,7 +1935,7 @@
+ 	return quotient;
+ }
+ 
+-
++#if !LINUX
+ #define __kCFUserEncodingFileName ("/.CFUserTextEncoding")
+ 
+ static UInt32
+@@ -1939,7 +1961,7 @@
+     }
+     return 0;
+ }
+-
++#endif
+ 
+ static int
+ ConvertUTF8toUnicode(const UInt8* source, UInt32 bufsize, UniChar* unibuf,
+@@ -2006,6 +2028,9 @@
+ static int
+ getencodinghint(unsigned char *name)
+ {
++#if LINUX
++	return(0);
++#else
+         int mib[3];
+         size_t buflen = sizeof(int);
+         struct vfsconf vfc;
+@@ -2023,7 +2048,8 @@
+ 	return (hint);
+ error:
+ 	hint = GetDefaultEncoding();
+-	return (hint);
++	return (0);
++#endif
+ }
+ 
+ 
+@@ -2034,12 +2060,14 @@
+ 	unsigned char digest[20];
+ 	time_t now;
+ 	clock_t uptime;
+-	int mib[2];
+-	int sysdata;
+-	char sysctlstring[128];
+ 	size_t datalen;
+ 	double sysloadavg[3];
++#if !LINUX
++	int sysdata;
++	int mib[2];
++	char sysctlstring[128];
+ 	struct vmtotal sysvmtotal;
++#endif
+ 	
+ 	do {
+ 		/* Initialize the SHA-1 context for processing: */
+@@ -2052,52 +2080,58 @@
+ 		SHA1_Update(&context, &uptime, sizeof(uptime));
+ 		
+ 		/* The kernel's boot time: */
++#if !LINUX
+ 		mib[0] = CTL_KERN;
+ 		mib[1] = KERN_BOOTTIME;
+ 		datalen = sizeof(sysdata);
+ 		sysctl(mib, 2, &sysdata, &datalen, NULL, 0);
+ 		SHA1_Update(&context, &sysdata, datalen);
+-		
++#endif
+ 		/* The system's host id: */
++#if !LINUX
+ 		mib[0] = CTL_KERN;
+ 		mib[1] = KERN_HOSTID;
+ 		datalen = sizeof(sysdata);
+ 		sysctl(mib, 2, &sysdata, &datalen, NULL, 0);
+ 		SHA1_Update(&context, &sysdata, datalen);
+-
++#endif
+ 		/* The system's host name: */
++#if !LINUX
+ 		mib[0] = CTL_KERN;
+ 		mib[1] = KERN_HOSTNAME;
+ 		datalen = sizeof(sysctlstring);
+ 		sysctl(mib, 2, sysctlstring, &datalen, NULL, 0);
+ 		SHA1_Update(&context, sysctlstring, datalen);
+-
++#endif
+ 		/* The running kernel's OS release string: */
++#if !LINUX
+ 		mib[0] = CTL_KERN;
+ 		mib[1] = KERN_OSRELEASE;
+ 		datalen = sizeof(sysctlstring);
+ 		sysctl(mib, 2, sysctlstring, &datalen, NULL, 0);
+ 		SHA1_Update(&context, sysctlstring, datalen);
+-
++#endif
+ 		/* The running kernel's version string: */
++#if !LINUX
+ 		mib[0] = CTL_KERN;
+ 		mib[1] = KERN_VERSION;
+ 		datalen = sizeof(sysctlstring);
+ 		sysctl(mib, 2, sysctlstring, &datalen, NULL, 0);
+ 		SHA1_Update(&context, sysctlstring, datalen);
+-
++#endif
+ 		/* The system's load average: */
+ 		datalen = sizeof(sysloadavg);
+ 		getloadavg(sysloadavg, 3);
+ 		SHA1_Update(&context, &sysloadavg, datalen);
+ 
+ 		/* The system's VM statistics: */
++#if !LINUX
+ 		mib[0] = CTL_VM;
+ 		mib[1] = VM_METER;
+ 		datalen = sizeof(sysvmtotal);
+ 		sysctl(mib, 2, &sysvmtotal, &datalen, NULL, 0);
+ 		SHA1_Update(&context, &sysvmtotal, datalen);
+-
++#endif
+ 		/* The current GMT (26 ASCII characters): */
+ 		time(&now);
+ 		strncpy(randomInputBuffer, asctime(gmtime(&now)), 26);	/* "Mon Mar 27 13:46:26 2000" */
+Index: hfsprogs-332.14/newfs_hfs.tproj/newfs_hfs.c
+===================================================================
+--- hfsprogs-332.14.orig/newfs_hfs.tproj/newfs_hfs.c	2008-10-07 05:08:02.000000000 -0300
++++ hfsprogs-332.14/newfs_hfs.tproj/newfs_hfs.c	2008-10-07 05:08:08.000000000 -0300
+@@ -38,8 +38,13 @@
+ #include <sys/mount.h>
+ #include <sys/param.h>
+ #include <sys/stat.h>
++#if LINUX
++#include <time.h>
++#endif
+ 
++#if !LINUX
+ #include <IOKit/storage/IOMediaBSDClient.h>
++#endif
+ 
+ #include <hfs/hfs_format.h>
+ #include "newfs_hfs.h"
+@@ -73,7 +78,9 @@
+ 
+ char	*progname;
+ char	gVolumeName[kHFSPlusMaxFileNameChars + 1] = {kDefaultVolumeNameStr};
++#if !LINUX
+ char	rawdevice[MAXPATHLEN];
++#endif
+ char	blkdevice[MAXPATHLEN];
+ UInt32	gBlockSize = 0;
+ UInt32	gNextCNID = kHFSFirstUserCatalogNodeID;
+@@ -137,8 +144,10 @@
+ 	extern int optind;
+ 	int ch;
+ 	int forceHFS;
++#if !LINUX
+ 	char *cp, *special;
+ 	struct statfs *mp;
++#endif
+ 	int n;
+ 	
+ 	if ((progname = strrchr(*argv, '/')))
+@@ -238,7 +247,9 @@
+ 
+ 	if (argc != 1)
+ 		usage();
+-
++#if LINUX
++	(void) sprintf(blkdevice, "%s", argv[0]);
++#else
+ 	special = argv[0];
+ 	cp = strrchr(special, '/');
+ 	if (cp != 0)
+@@ -247,6 +258,7 @@
+ 		special++;
+ 	(void) sprintf(rawdevice, "%sr%s", _PATH_DEV, special);
+ 	(void) sprintf(blkdevice, "%s%s", _PATH_DEV, special);
++#endif
+ 
+ 	if (forceHFS && gJournaled) {
+ 		fprintf(stderr, "-h -J: incompatible options specified\n");
+@@ -268,6 +280,9 @@
+ 	/*
+ 	 * Check if target device is aready mounted
+ 	 */
++#if LINUX
++	// FIXME
++#else
+ 	n = getmntinfo(&mp, MNT_NOWAIT);
+ 	if (n == 0)
+ 		fatal("%s: getmntinfo: %s", blkdevice, strerror(errno));
+@@ -277,14 +292,19 @@
+ 			fatal("%s is mounted on %s", blkdevice, mp->f_mntonname);
+ 		++mp;
+ 	}
++#endif
+ 
+-	if (hfs_newfs(rawdevice, forceHFS, true) < 0) {
++	if (hfs_newfs(blkdevice, forceHFS, true) < 0) {
++#if LINUX
++		err(1, NULL);
++#else
+ 		/* On ENXIO error use the block device (to get de-blocking) */
+ 		if (errno == ENXIO) {
+ 			if (hfs_newfs(blkdevice, forceHFS, false) < 0)
+ 				err(1, NULL);
+ 		} else
+ 			err(1, NULL);
++#endif
+ 	}
+ 
+ 	exit(0);
+@@ -458,7 +478,7 @@
+ 			fatal("%s: block size is too small for %lld sectors", optarg, gBlockSize, sectorCount);
+ 
+ 		if (gBlockSize < HFSOPTIMALBLKSIZE)
+-			warnx("Warning: %ld is a non-optimal block size (4096 would be a better choice)", gBlockSize);
++			warnx("Warning: %i is a non-optimal block size (4096 would be a better choice)", gBlockSize);
+ 	}
+ }
+ 
+@@ -472,7 +492,9 @@
+ 	int fso = 0;
+ 	int retval = 0;
+ 	hfsparams_t defaults = {0};
++#if !LINUX
+ 	u_int64_t maxSectorsPerIO;
++#endif
+ 
+ 	if (gNoCreate) {
+ 		fso = open( device, O_RDONLY | O_NDELAY, 0 );
+@@ -485,7 +507,33 @@
+ 
+ 	if (fstat( fso, &stbuf) < 0)
+ 		fatal("%s: %s", device, strerror(errno));
++#if LINUX
++	dip.sectorSize = 512;
++	dip.sectorsPerIO = 256;
+ 
++#ifndef	BLKGETSIZE
++#define	BLKGETSIZE		_IO(0x12,96)
++#endif
++#ifndef	BLKGETSIZE64
++#define BLKGETSIZE64		_IOR(0x12,114,size_t)
++#endif
++
++	if (S_ISREG(stbuf.st_mode)) {
++                dip.totalSectors = stbuf.st_size / 512;
++        }
++	else if (S_ISBLK(stbuf.st_mode)) {
++                unsigned long size;
++                u_int64_t size64;
++                if (!ioctl(fso, BLKGETSIZE64, &size64))
++                        dip.totalSectors = size64 / 512;
++                else if (!ioctl(fso, BLKGETSIZE, &size))
++                        dip.totalSectors = size;
++                else
++                        fatal("%s: %s", device, strerror(errno));
++        }
++	else
++                fatal("%s: is not a block device", device);
++#else
+ 	if (ioctl(fso, DKIOCGETBLOCKCOUNT, &dip.totalSectors) < 0)
+ 		fatal("%s: %s", device, strerror(errno));
+ 
+@@ -493,14 +541,17 @@
+ 		fatal("%s: %s", device, strerror(errno));
+ 
+ 	if (ioctl(fso, DKIOCGETMAXBLOCKCOUNTWRITE, &maxSectorsPerIO) < 0)
+-		dip.sectorsPerIO = (128 * 1024) / dip.sectorSize;  /* use 128K as default */
++		dip.sectorsPerIO = (128 * 1024) / dip.sectorSize; /* use 128K as default */
+ 	else
+ 		dip.sectorsPerIO = MIN(maxSectorsPerIO, (1024 * 1024) / dip.sectorSize);
++#endif
++
+         /*
+-         * The make_hfs code currentlydoes 512 byte sized I/O.
++         * The make_hfs code currently does 512 byte sized I/O.
+          * If the sector size is bigger than 512, start over
+          * using the block device (to get de-blocking).
+          */       
++#if !LINUX
+         if (dip.sectorSize != kBytesPerSector) {
+ 		if (isRaw) {
+ 			close(fso);
+@@ -515,7 +566,8 @@
+ 			dip.sectorSize = kBytesPerSector;
+ 		}
+         }
+-  
++#endif
++
+ 	dip.fd = fso;
+ 	dip.sectorOffset = 0;
+ 	time(&createtime);
+@@ -693,7 +745,7 @@
+ 	defaults->catalogClumpSize = clumpSize;
+ 	defaults->catalogNodeSize = catnodesiz;
+ 	if (gBlockSize < 4096 && gBlockSize < catnodesiz)
+-		warnx("Warning: block size %ld is less than catalog b-tree node size %ld", gBlockSize, catnodesiz);
++		warnx("Warning: block size %i is less than catalog b-tree node size %i", gBlockSize, catnodesiz);
+ 
+ 	if (extclumpblks == 0) {
+ 		clumpSize = CalcHFSPlusBTreeClumpSize(gBlockSize, extnodesiz, sectorCount, FALSE);
+@@ -706,7 +758,7 @@
+ 	defaults->extentsClumpSize = clumpSize;
+ 	defaults->extentsNodeSize = extnodesiz;
+ 	if (gBlockSize < extnodesiz)
+-		warnx("Warning: block size %ld is less than extents b-tree node size %ld", gBlockSize, extnodesiz);
++		warnx("Warning: block size %i is less than extents b-tree node size %i", gBlockSize, extnodesiz);
+ 
+ 	if (atrclumpblks == 0) {
+ 		clumpSize = 0;
+@@ -754,22 +806,22 @@
+ 
+ 	if (gNoCreate) {
+ 		if (!gWrapper)
+-			printf("%qd sectors (%lu bytes per sector)\n", sectorCount, sectorSize);
++			printf("%lld sectors (%u bytes per sector)\n", sectorCount, sectorSize);
+ 		printf("HFS Plus format parameters:\n");
+ 		printf("\tvolume name: \"%s\"\n", gVolumeName);
+-		printf("\tblock-size: %lu\n", defaults->blockSize);
+-		printf("\ttotal blocks: %lu\n", totalBlocks);
++		printf("\tblock-size: %u\n", defaults->blockSize);
++		printf("\ttotal blocks: %u\n", totalBlocks);
+ 		if (gJournaled)
+ 			printf("\tjournal-size: %dk\n", (int)defaults->journalSize/1024);
+-		printf("\tfirst free catalog node id: %lu\n", defaults->nextFreeFileID);
+-		printf("\tcatalog b-tree node size: %lu\n", defaults->catalogNodeSize);
+-		printf("\tinitial catalog file size: %lu\n", defaults->catalogClumpSize);
+-		printf("\textents b-tree node size: %lu\n", defaults->extentsNodeSize);
+-		printf("\tinitial extents file size: %lu\n", defaults->extentsClumpSize);
+-		printf("\tinitial allocation file size: %lu (%lu blocks)\n",
++		printf("\tfirst free catalog node id: %u\n", defaults->nextFreeFileID);
++		printf("\tcatalog b-tree node size: %u\n", defaults->catalogNodeSize);
++		printf("\tinitial catalog file size: %u\n", defaults->catalogClumpSize);
++		printf("\textents b-tree node size: %u\n", defaults->extentsNodeSize);
++		printf("\tinitial extents file size: %u\n", defaults->extentsClumpSize);
++		printf("\tinitial allocation file size: %u (%u blocks)\n",
+ 			defaults->allocationClumpSize, defaults->allocationClumpSize / gBlockSize);
+-		printf("\tdata fork clump size: %lu\n", defaults->dataClumpSize);
+-		printf("\tresource fork clump size: %lu\n", defaults->rsrcClumpSize);
++		printf("\tdata fork clump size: %u\n", defaults->dataClumpSize);
++		printf("\tresource fork clump size: %u\n", defaults->rsrcClumpSize);
+ 		if (defaults->flags & kUseAccessPerms) {
+ 			printf("\tuser ID: %d\n", (int)defaults->owner);
+ 			printf("\tgroup ID: %d\n", (int)defaults->group);
+@@ -844,17 +896,17 @@
+ 	}
+ 	
+ 	if (gNoCreate) {
+-		printf("%ld sectors at %ld bytes per sector\n", sectorCount, sectorSize);
++		printf("%i sectors at %i bytes per sector\n", sectorCount, sectorSize);
+ 		printf("%s format parameters:\n", gWrapper ? "HFS Wrapper" : "HFS");
+ 		printf("\tvolume name: \"%s\"\n", gVolumeName);
+-		printf("\tblock-size: %ld\n", defaults->blockSize);
+-		printf("\ttotal blocks: %ld\n", sectorCount / (alBlkSize / sectorSize) );
+-		printf("\tfirst free catalog node id: %ld\n", defaults->nextFreeFileID);
+-		printf("\tinitial catalog file size: %ld\n", defaults->catalogClumpSize);
+-		printf("\tinitial extents file size: %ld\n", defaults->extentsClumpSize);
+-		printf("\tfile clump size: %ld\n", defaults->dataClumpSize);
++		printf("\tblock-size: %i\n", defaults->blockSize);
++		printf("\ttotal blocks: %i\n", sectorCount / (alBlkSize / sectorSize) );
++		printf("\tfirst free catalog node id: %i\n", defaults->nextFreeFileID);
++		printf("\tinitial catalog file size: %i\n", defaults->catalogClumpSize);
++		printf("\tinitial extents file size: %i\n", defaults->extentsClumpSize);
++		printf("\tfile clump size: %i\n", defaults->dataClumpSize);
+ 		if (hfsgrowblks)
+-			printf("\twrapper growable from %ld to %ld sectors\n", sectorCount, hfsgrowblks);
++			printf("\twrapper growable from %i to %i sectors\n", sectorCount, hfsgrowblks);
+ 	}
+ }
+ 
+Index: hfsprogs-332.14/newfs_hfs.tproj/newfs_hfs.h
+===================================================================
+--- hfsprogs-332.14.orig/newfs_hfs.tproj/newfs_hfs.h	2008-10-07 05:08:02.000000000 -0300
++++ hfsprogs-332.14/newfs_hfs.tproj/newfs_hfs.h	2008-10-07 05:08:08.000000000 -0300
+@@ -19,8 +19,12 @@
+  * 
+  * @APPLE_LICENSE_HEADER_END@
+  */
+- 
+-#include <CoreFoundation/CFBase.h>
++
++#if LINUX
++#include "missing.h"
++#else
++#include <CoreFoundation/CFBase.h>*/
++#endif
+ 
+ /*
+  * Mac OS Finder flags
+@@ -122,33 +126,33 @@
+ #define kDTDF_FileID	16
+ #define kDTDF_Name	"Desktop DF"
+ #define kDTDF_Chars	10
+-#define kDTDF_Type	'DTFL'
+-#define kDTDF_Creator	'DMGR'
++#define kDTDF_Type	0x4454464C /* 'DTFL' */
++#define kDTDF_Creator	0x444D4752 /* 'DMGR' */
+ 
+ #define kDTDB_FileID	17
+ #define kDTDB_Name	"Desktop DB"
+ #define kDTDB_Chars	10
+-#define kDTDB_Type	'BTFL'
+-#define kDTDB_Creator	'DMGR'
++#define kDTDB_Type	0x4254464C /* 'BTFL' */
++#define kDTDB_Creator	0x444D4752 /* 'DMGR' */
+ #define kDTDB_Size	1024
+ 
+ #define kReadMe_FileID	18
+ #define kReadMe_Name	"ReadMe"
+ #define kReadMe_Chars	6
+-#define kReadMe_Type	'ttro'
+-#define kReadMe_Creator	'ttxt'
++#define kReadMe_Type	0x7474726F /* 'ttro' */
++#define kReadMe_Creator	0x74747974 /* 'ttxt' */
+ 
+ #define kFinder_FileID	19
+ #define kFinder_Name	"Finder"
+ #define kFinder_Chars	6
+-#define kFinder_Type	'FNDR'
+-#define kFinder_Creator	'MACS'
++#define kFinder_Type	0x464E4452 /* 'FNDR' */
++#define kFinder_Creator	0x4D414353 /* 'MACS' */
+ 
+ #define kSystem_FileID	20
+ #define kSystem_Name	"System"
+ #define kSystem_Chars	6
+-#define kSystem_Type	'zsys'
+-#define kSystem_Creator	'MACS'
++#define kSystem_Type	0x7A737973 /* 'zsys' */
++#define kSystem_Creator	0x4D414353 /* 'MACS' */
+ 
+ 
+ 
--- hfsprogs-332.14.orig/debian/patches/70-diskdev_cmds_system_check-332.14.patch
+++ hfsprogs-332.14/debian/patches/70-diskdev_cmds_system_check-332.14.patch
@@ -0,0 +1,30 @@
+Index: hfsprogs-332.14/fsck_hfs.tproj/fsck_hfs.c
+===================================================================
+--- hfsprogs-332.14.orig/fsck_hfs.tproj/fsck_hfs.c	2008-10-07 05:08:08.000000000 -0300
++++ hfsprogs-332.14/fsck_hfs.tproj/fsck_hfs.c	2008-10-07 05:08:18.000000000 -0300
+@@ -109,7 +109,7 @@
+ 	else
+ 		progname = *argv;
+ 
+-	while ((ch = getopt(argc, argv, "dfglm:npqruy")) != EOF) {
++	while ((ch = getopt(argc, argv, "dfglm:napqruy")) != EOF) {
+ 		switch (ch) {
+ 		case 'd':
+ 			debug++;
+@@ -145,6 +145,7 @@
+ 			yflag = 0;
+ 			break;
+ 
++		case 'a':
+ 		case 'p':
+ 			preen++;
+ 			break;
+@@ -535,7 +536,7 @@
+ 	(void) fprintf(stderr, "  l = live fsck (lock down and test-only)\n");
+ 	(void) fprintf(stderr, "  m arg = octal mode used when creating lost+found directory \n");
+ 	(void) fprintf(stderr, "  n = assume a no response \n");
+-	(void) fprintf(stderr, "  p = just fix normal inconsistencies \n");
++	(void) fprintf(stderr, "  p, a = just fix normal inconsistencies \n");
+ 	(void) fprintf(stderr, "  q = quick check returns clean, dirty, or failure \n");
+ 	(void) fprintf(stderr, "  r = rebuild catalog btree \n");
+ 	(void) fprintf(stderr, "  u = usage \n");
--- hfsprogs-332.14.orig/debian/patches/00-create_makefiles.patch
+++ hfsprogs-332.14/debian/patches/00-create_makefiles.patch
@@ -0,0 +1,70 @@
+Index: hfsprogs-332.14/Makefile.lnx
+===================================================================
+--- /dev/null	1970-01-01 00:00:00.000000000 +0000
++++ hfsprogs-332.14/Makefile.lnx	2008-10-07 05:08:06.000000000 -0300
+@@ -0,0 +1,8 @@
++CC := gcc
++CFLAGS := -g3 -Wall -I$(PWD)/include -DDEBUG_BUILD=0 -D_FILE_OFFSET_BITS=64 -D LINUX=1 -D BSD=1
++SUBDIRS := newfs_hfs.tproj fsck_hfs.tproj
++
++all clean:
++	for d in $(SUBDIRS); do $(MAKE) -C $$d -f Makefile.lnx $@; done
++
++export CC CFLAGS
+Index: hfsprogs-332.14/fsck_hfs.tproj/Makefile.lnx
+===================================================================
+--- /dev/null	1970-01-01 00:00:00.000000000 +0000
++++ hfsprogs-332.14/fsck_hfs.tproj/Makefile.lnx	2008-10-07 05:08:06.000000000 -0300
+@@ -0,0 +1,15 @@
++CFILES = fsck_hfs.c strings.c utilities.c cache.c
++OFILES = $(CFILES:.c=.o)
++
++all: fsck_hfs
++
++fsck_hfs: $(OFILES) dfalib/libdfa.a
++
++dfalib/libdfa.a: FORCE
++	$(MAKE) -C dfalib -f Makefile.lnx libdfa.a
++
++clean:
++	$(RM) fsck_hfs $(OFILES)
++	$(MAKE) -C dfalib -f Makefile.lnx clean
++
++.PHONY : FORCE clean
+Index: hfsprogs-332.14/fsck_hfs.tproj/dfalib/Makefile.lnx
+===================================================================
+--- /dev/null	1970-01-01 00:00:00.000000000 +0000
++++ hfsprogs-332.14/fsck_hfs.tproj/dfalib/Makefile.lnx	2008-10-07 05:08:06.000000000 -0300
+@@ -0,0 +1,15 @@
++CFILES = hfs_endian.c BlockCache.c\
++         BTree.c BTreeAllocate.c BTreeMiscOps.c \
++         BTreeNodeOps.c BTreeScanner.c BTreeTreeOps.c\
++         CatalogCheck.c HardLinkCheck.c\
++         SBTree.c SControl.c SVerify1.c SVerify2.c\
++         SRepair.c SRebuildCatalogBTree.c\
++         SUtils.c SKeyCompare.c SDevice.c SExtents.c SAllocate.c\
++         SCatalog.c SStubs.c VolumeBitmapCheck.c
++OFILES = $(CFILES:.c=.o)
++
++libdfa.a: $(OFILES)
++	ar rc $@ $?
++
++clean:
++	$(RM) $(OFILES) libdfa.a
+Index: hfsprogs-332.14/newfs_hfs.tproj/Makefile.lnx
+===================================================================
+--- /dev/null	1970-01-01 00:00:00.000000000 +0000
++++ hfsprogs-332.14/newfs_hfs.tproj/Makefile.lnx	2008-10-07 05:08:06.000000000 -0300
+@@ -0,0 +1,12 @@
++CFILES = hfs_endian.c makehfs.c newfs_hfs.c
++OFILES = $(CFILES:.c=.o)
++
++all: newfs_hfs
++
++newfs_hfs: $(OFILES)
++	${CC} ${CFLAGS} -o newfs_hfs ${OFILES} -lssl
++
++clean:
++	$(RM) newfs_hfs $(OFILES)
++
++.PHONY : FORCE clean
--- hfsprogs-332.14.orig/debian/patches/series
+++ hfsprogs-332.14/debian/patches/series
@@ -0,0 +1,9 @@
+00-create_makefiles.patch
+10-linux_specific_code.patch
+20-apple_specific_files.patch
+30-formatting_strings.patch
+40-printf_types.patch
+50-typo-new_fs-manpage.diff
+60-hfs-wrapper-boot-in-usr-share.diff
+70-diskdev_cmds_system_check-332.14.patch
+80-remove_see-also_from_manpage.patch
--- hfsprogs-332.14.orig/debian/patches/80-remove_see-also_from_manpage.patch
+++ hfsprogs-332.14/debian/patches/80-remove_see-also_from_manpage.patch
@@ -0,0 +1,12 @@
+--- hfsprogs-332.14/newfs_hfs.tproj/newfs_hfs.8.orig	2008-10-07 05:46:44.000000000 -0300
++++ hfsprogs-332.14/newfs_hfs.tproj/newfs_hfs.8	2008-10-07 06:02:52.000000000 -0300
+@@ -139,8 +139,7 @@
+ Volume name (file system name) in ascii or UTF-8 format.
+ .El
+ .Sh SEE ALSO
+-.Xr mount 8 ,
+-.Xr pdisk 8
++.Xr mount 8
+ .Sh HISTORY
+ The
+ .Nm
--- hfsprogs-332.14.orig/debian/patches/30-formatting_strings.patch
+++ hfsprogs-332.14/debian/patches/30-formatting_strings.patch
@@ -0,0 +1,280 @@
+Index: hfsprogs-332.14/fsck_hfs.tproj/dfalib/BTreeTreeOps.c
+===================================================================
+--- hfsprogs-332.14.orig/fsck_hfs.tproj/dfalib/BTreeTreeOps.c	2008-10-07 05:08:02.000000000 -0300
++++ hfsprogs-332.14/fsck_hfs.tproj/dfalib/BTreeTreeOps.c	2008-10-07 05:08:12.000000000 -0300
+@@ -223,7 +223,7 @@
+         //
+         if (curNodeNum == 0)
+         {
+-//          Panic("\pSearchTree: curNodeNum is zero!");
++            Panic("SearchTree: curNodeNum is zero!");
+             err = fsBTInvalidNodeErr;
+             goto ErrorExit;
+         }
+@@ -433,7 +433,7 @@
+ 		M_ExitOnError (err);
+ 		
+ 		if ( DEBUG_BUILD && updateParent && newRoot )
+-			DebugStr("\p InsertLevel: New root from primary key, update from secondary key...");
++			DebugStr("InsertLevel: New root from primary key, update from secondary key...");
+ 	}
+ 
+ 	//////////////////////// Update Parent(s) ///////////////////////////////
+@@ -448,7 +448,7 @@
+ 		
+ 		secondaryKey = nil;
+ 		
+-		PanicIf ( (level == btreePtr->treeDepth), "\p InsertLevel: unfinished insert!?");
++		PanicIf ( (level == btreePtr->treeDepth), "InsertLevel: unfinished insert!?");
+ 
+ 		++level;
+ 
+@@ -456,7 +456,7 @@
+ 		index = treePathTable [level].index;
+ 		parentNodeNum = treePathTable [level].node;
+ 
+-		PanicIf ( parentNodeNum == 0, "\p InsertLevel: parent node is zero!?");
++		PanicIf ( parentNodeNum == 0, "InsertLevel: parent node is zero!?");
+ 
+ 		err = GetNode (btreePtr, parentNodeNum, &parentNode);	// released as target node in next level up
+ 		M_ExitOnError (err);
+@@ -470,7 +470,7 @@
+ 		{
+ 			//孕佁ebug: check if ptr == targetNodeNum
+ 			GetRecordByIndex (btreePtr, parentNode.buffer, index, &keyPtr, &recPtr, &recSize);
+-			PanicIf( (*(UInt32 *) recPtr) != targetNodeNum, "\p InsertLevel: parent ptr doesn't match target node!");
++			PanicIf( (*(UInt32 *) recPtr) != targetNodeNum, "InsertLevel: parent ptr doesn't match target node!");
+ 			
+ 			// need to delete and re-insert this parent key/ptr
+ 			// we delete it here and it gets re-inserted in the
+@@ -532,7 +532,7 @@
+ 	(void) ReleaseNode (btreePtr, targetNode);
+ 	(void) ReleaseNode (btreePtr, &siblingNode);
+ 
+-	Panic ("\p InsertLevel: an error occured!");
++	Panic ("InsertLevel: an error occured!");
+ 
+ 	return	err;
+ 
+@@ -566,7 +566,7 @@
+ 
+ 	*rootSplit = false;
+ 	
+-	PanicIf ( targetNode->buffer == siblingNode->buffer, "\p InsertNode: targetNode == siblingNode, huh?");
++	PanicIf ( targetNode->buffer == siblingNode->buffer, "InsertNode: targetNode == siblingNode, huh?");
+ 	
+ 	leftNodeNum = ((NodeDescPtr) targetNode->buffer)->bLink;
+ 	rightNodeNum = ((NodeDescPtr) targetNode->buffer)->fLink;
+@@ -606,7 +606,7 @@
+ 	
+ 	if ( leftNodeNum > 0 )
+ 	{
+-		PanicIf ( siblingNode->buffer != nil, "\p InsertNode: siblingNode already aquired!");
++		PanicIf ( siblingNode->buffer != nil, "InsertNode: siblingNode already aquired!");
+ 
+ 		if ( siblingNode->buffer == nil )
+ 		{
+@@ -614,7 +614,7 @@
+ 			M_ExitOnError (err);
+ 		}
+ 
+-		PanicIf ( ((NodeDescPtr) siblingNode->buffer)->fLink != nodeNum, "\p InsertNode, RotateLeft: invalid sibling link!" );
++		PanicIf ( ((NodeDescPtr) siblingNode->buffer)->fLink != nodeNum, "InsertNode, RotateLeft: invalid sibling link!" );
+ 
+ 		if ( !key->skipRotate )		// are rotates allowed?
+ 		{
+@@ -703,7 +703,7 @@
+ 
+ 	targetNodeNum = treePathTable[level].node;
+ 	targetNodePtr = targetNode->buffer;
+-	PanicIf (targetNodePtr == nil, "\pDeleteTree: targetNode has nil buffer!");
++	PanicIf (targetNodePtr == nil, "DeleteTree: targetNode has nil buffer!");
+ 
+ 	DeleteRecord (btreePtr, targetNodePtr, index);
+ 		
+@@ -797,7 +797,7 @@
+ 			 
+ 			//孕佁ebug: check if ptr == targetNodeNum
+ 			GetRecordByIndex (btreePtr, parentNode.buffer, index, &keyPtr, &recPtr, &recSize);
+-			PanicIf( (*(UInt32 *) recPtr) != targetNodeNum, "\p DeleteTree: parent ptr doesn't match targetNodeNum!!");
++			PanicIf( (*(UInt32 *) recPtr) != targetNodeNum, " DeleteTree: parent ptr doesn't match targetNodeNum!!");
+ 			
+ 			// need to delete and re-insert this parent key/ptr
+ 			DeleteRecord (btreePtr, parentNode.buffer, index);
+@@ -1018,7 +1018,7 @@
+ 										keyPtr, keyLength, recPtr, recSize);
+ 			if ( !didItFit )
+ 			{
+-				Panic ("\pRotateLeft: InsertKeyRecord (left) returned false!");
++				Panic ("RotateLeft: InsertKeyRecord (left) returned false!");
+ 				err = fsBTBadRotateErr;
+ 				goto ErrorExit;
+ 			}
+@@ -1031,7 +1031,7 @@
+ 			didItFit = RotateRecordLeft (btreePtr, leftNode, rightNode);
+ 			if ( !didItFit )
+ 			{
+-				Panic ("\pRotateLeft: RotateRecordLeft returned false!");
++				Panic ("RotateLeft: RotateRecordLeft returned false!");
+ 				err = fsBTBadRotateErr;
+ 				goto ErrorExit;
+ 			}
+@@ -1048,7 +1048,7 @@
+ 									keyPtr, keyLength, recPtr, recSize);
+ 		if ( !didItFit )
+ 		{
+-			Panic ("\pRotateLeft: InsertKeyRecord (right) returned false!");
++			Panic ("RotateLeft: InsertKeyRecord (right) returned false!");
+ 			err = fsBTBadRotateErr;
+ 			goto ErrorExit;
+ 		}
+@@ -1117,7 +1117,7 @@
+ 	right = rightNode->buffer;
+ 	left  = leftNode->buffer;
+ 	
+-	PanicIf ( right->bLink != 0 && left == 0, "\p SplitLeft: left sibling missing!?" );
++	PanicIf ( right->bLink != 0 && left == 0, " SplitLeft: left sibling missing!?" );
+ 	
+ 	//孕 type should be kLeafNode or kIndexNode
+ 	
+@@ -1240,8 +1240,8 @@
+ 	Boolean				didItFit;
+ 	UInt16				keyLength;	
+ 	
+-	PanicIf (leftNode == nil, "\pAddNewRootNode: leftNode == nil");
+-	PanicIf (rightNode == nil, "\pAddNewRootNode: rightNode == nil");
++	PanicIf (leftNode == nil, "AddNewRootNode: leftNode == nil");
++	PanicIf (rightNode == nil, "AddNewRootNode: rightNode == nil");
+ 	
+ 	
+ 	/////////////////////// Initialize New Root Node ////////////////////////////
+@@ -1264,7 +1264,7 @@
+ 	didItFit = InsertKeyRecord ( btreePtr, rootNode.buffer, 0, keyPtr, keyLength,
+ 								 (UInt8 *) &rightNode->bLink, 4 );
+ 
+-	PanicIf ( !didItFit, "\pAddNewRootNode:InsertKeyRecord failed for left index record");
++	PanicIf ( !didItFit, "AddNewRootNode:InsertKeyRecord failed for left index record");
+ 
+ 
+ 	//////////////////// Insert Right Node Index Record /////////////////////////
+@@ -1275,7 +1275,7 @@
+ 	didItFit = InsertKeyRecord ( btreePtr, rootNode.buffer, 1, keyPtr, keyLength,
+ 								 (UInt8 *) &leftNode->fLink, 4 );
+ 
+-	PanicIf ( !didItFit, "\pAddNewRootNode:InsertKeyRecord failed for right index record");
++	PanicIf ( !didItFit, "AddNewRootNode:InsertKeyRecord failed for right index record");
+ 
+ 
+ #if DEBUG_TREEOPS
+@@ -1355,7 +1355,7 @@
+ 	}
+ 	rightPtr = rightNodePtr->buffer;
+ 	
+-	PanicIf ( leftPtr->fLink != 0 && rightPtr == 0, "\p SplitRight: right sibling missing!?" );
++	PanicIf ( leftPtr->fLink != 0 && rightPtr == 0, "SplitRight: right sibling missing!?" );
+ 	
+ 	//孕 type should be kLeafNode or kIndexNode
+ 	
+@@ -1557,7 +1557,7 @@
+ 									keyPtr, keyLength, recPtr, recSize);
+ 		if ( !didItFit )
+ 		{
+-			Panic ("\pRotateRight: InsertKeyRecord (left) returned false!");
++			Panic ("RotateRight: InsertKeyRecord (left) returned false!");
+ 			err = fsBTBadRotateErr;
+ 			goto ErrorExit;
+ 		}
+@@ -1572,7 +1572,7 @@
+ 		didItFit = RotateRecordRight( btreePtr, leftNodePtr, rightNodePtr );
+ 		if ( !didItFit )
+ 		{
+-			Panic ("\pRotateRight: RotateRecordRight returned false!");
++			Panic ("RotateRight: RotateRecordRight returned false!");
+ 			err = fsBTBadRotateErr;
+ 			goto ErrorExit;
+ 		}
+@@ -1583,7 +1583,7 @@
+ 										keyPtr, keyLength, recPtr, recSize);
+ 			if ( !didItFit )
+ 			{
+-				Panic ("\pRotateRight: InsertKeyRecord (left) returned false!");
++				Panic ("RotateRight: InsertKeyRecord (left) returned false!");
+ 				err = fsBTBadRotateErr;
+ 				goto ErrorExit;
+ 			}
+@@ -1607,7 +1607,7 @@
+ 									keyPtr, keyLength, recPtr, recSize);
+ 		if ( !didItFit )
+ 		{
+-			Panic ("\pRotateRight: InsertKeyRecord (right) returned false!");
++			Panic ("RotateRight: InsertKeyRecord (right) returned false!");
+ 			err = fsBTBadRotateErr;
+ 			goto ErrorExit;
+ 		}
+Index: hfsprogs-332.14/fsck_hfs.tproj/dfalib/SBTree.c
+===================================================================
+--- hfsprogs-332.14.orig/fsck_hfs.tproj/dfalib/SBTree.c	2008-10-07 05:08:08.000000000 -0300
++++ hfsprogs-332.14/fsck_hfs.tproj/dfalib/SBTree.c	2008-10-07 05:08:12.000000000 -0300
+@@ -93,7 +93,7 @@
+ 			CopyMemory(&resultIterator->key, foundKey, CalcKeySize(btcb, &resultIterator->key));	//孕 warning, this could overflow user's buffer!!!
+ 
+ 		if ( DEBUG_BUILD && !ValidHFSRecord(data, btcb, *dataSize) )
+-			DebugStr("\pSearchBTreeRecord: bad record?");
++			DebugStr("SearchBTreeRecord: bad record?");
+ 	}
+ 
+ ErrorExit:
+@@ -190,7 +190,7 @@
+ 		CopyMemory(&iterator->key, key, CalcKeySize(btcb, &iterator->key));	//孕 warning, this could overflow user's buffer!!!
+ 		
+ 		if ( DEBUG_BUILD && !ValidHFSRecord(data, btcb, *dataSize) )
+-			DebugStr("\pGetBTreeRecord: bad record?");
++			DebugStr("GetBTreeRecord: bad record?");
+ 
+ 	}
+ 	
+@@ -222,7 +222,7 @@
+ 	CopyMemory(key, &iterator.key, CalcKeySize(btcb, (BTreeKey *) key));	//孕 should we range check against maxkeylen?
+ 
+ 	if ( DEBUG_BUILD && !ValidHFSRecord(data, btcb, dataSize) )
+-		DebugStr("\pInsertBTreeRecord: bad record?");
++		DebugStr("InsertBTreeRecord: bad record?");
+ 
+ 	result = BTInsertRecord( fcb, &iterator, &btRecord, dataSize );
+ 
+@@ -284,7 +284,7 @@
+ 	CopyMemory(key, &iterator.key, CalcKeySize(btcb, (BTreeKey *) key));		//孕 should we range check against maxkeylen?
+ 
+ 	if ( DEBUG_BUILD && !ValidHFSRecord(newData, btcb, dataSize) )
+-		DebugStr("\pReplaceBTreeRecord: bad record?");
++		DebugStr("ReplaceBTreeRecord: bad record?");
+ 
+ 	result = BTReplaceRecord( fcb, &iterator, &btRecord, dataSize );
+ 
+@@ -323,7 +323,7 @@
+ 	else
+ 	{
+ 		if ( DEBUG_BUILD )
+-			DebugStr("\pSetEndOfForkProc: minEOF is smaller than current size!");
++			DebugStr("SetEndOfForkProc: minEOF is smaller than current size!");
+ 		return -1;
+ 	}
+ 
+@@ -349,7 +349,7 @@
+ 	//	Make sure we got at least as much space as we needed
+ 	//
+ 	if (filePtr->fcbLogicalSize < minEOF) {
+-		Panic("\pSetEndOfForkProc: disk too full to extend B-tree file");
++		Panic("SetEndOfForkProc: disk too full to extend B-tree file");
+ 		return dskFulErr;
+ 	}
+ 	
+@@ -421,7 +421,7 @@
+ 	if ( (keyLen < 6) || (keyLen > btcb->maxKeyLength) )
+ 	{
+ 		if ( DEBUG_BUILD )
+-			DebugStr("\pCheckBTreeKey: bad key length!");
++			DebugStr("CheckBTreeKey: bad key length!");
+ 		return fsBTInvalidKeyLengthErr;
+ 	}
+ 	
--- hfsprogs-332.14.orig/debian/patches/40-printf_types.patch
+++ hfsprogs-332.14/debian/patches/40-printf_types.patch
@@ -0,0 +1,26 @@
+Index: hfsprogs-332.14/fsck_hfs.tproj/dfalib/SControl.c
+===================================================================
+--- hfsprogs-332.14.orig/fsck_hfs.tproj/dfalib/SControl.c	2008-10-07 05:08:02.000000000 -0300
++++ hfsprogs-332.14/fsck_hfs.tproj/dfalib/SControl.c	2008-10-07 05:08:14.000000000 -0300
+@@ -739,7 +739,7 @@
+ 		pointer = (ScavStaticStructures *) AllocateClearMemory( sizeof(ScavStaticStructures) );
+ 		if ( pointer == nil ) {
+ 			if ( GPtr->logLevel >= kDebugLog ) {
+-				printf( "\t error %d - could not allocate %ld bytes of memory \n",
++				printf( "\t error %d - could not allocate %i bytes of memory \n",
+ 					R_NoMem, sizeof(ScavStaticStructures) );
+ 			}
+ 			return( R_NoMem );
+Index: hfsprogs-332.14/fsck_hfs.tproj/dfalib/hfs_endian.c
+===================================================================
+--- hfsprogs-332.14.orig/fsck_hfs.tproj/dfalib/hfs_endian.c	2008-10-07 05:08:08.000000000 -0300
++++ hfsprogs-332.14/fsck_hfs.tproj/dfalib/hfs_endian.c	2008-10-07 05:08:14.000000000 -0300
+@@ -563,7 +563,7 @@
+             /* Make sure name length is consistent with key length */
+             if (keyLength < sizeof(srcKey->parentID) + sizeof(srcKey->nodeName.length) +
+                 srcKey->nodeName.length*sizeof(srcKey->nodeName.unicode[0])) {
+-				if (debug) printf("hfs_swap_HFSPlusBTInternalNode: catalog record #%d keyLength=%d expected=%lu\n",
++				if (debug) printf("hfs_swap_HFSPlusBTInternalNode: catalog record #%d keyLength=%d expected=%i\n",
+ 					srcDesc->numRecords-i, keyLength, sizeof(srcKey->parentID) + sizeof(srcKey->nodeName.length) +
+                     srcKey->nodeName.length*sizeof(srcKey->nodeName.unicode[0]));
+ 				WriteError(fcb->fcbVolume->vcbGPtr, E_KeyLen, fcb->fcbFileID, src->blockNum);
--- hfsprogs-332.14.orig/debian/patches/50-typo-new_fs-manpage.diff
+++ hfsprogs-332.14/debian/patches/50-typo-new_fs-manpage.diff
@@ -0,0 +1,22 @@
+Index: hfsprogs-332.14/newfs_hfs.tproj/newfs_hfs.8
+===================================================================
+--- hfsprogs-332.14.orig/newfs_hfs.tproj/newfs_hfs.8	2008-10-07 05:08:02.000000000 -0300
++++ hfsprogs-332.14/newfs_hfs.tproj/newfs_hfs.8	2008-10-07 05:08:16.000000000 -0300
+@@ -93,7 +93,7 @@
+ option followed by a comma
+ separated list of the form arg=blocks.
+ .Pp
+-Example:  -c c=5000,e=500
++Example:  \-c c=5000,e=500
+ .Bl -tag -width Fl
+ .It Em a=blocks
+ Set the attribute file clump size.
+@@ -126,7 +126,7 @@
+ size must be a power of two and no larger than
+ 32768 bytes.
+ .Pp
+-Example:  -n c=8192,e=4096
++Example:  \-n c=8192,e=4096
+ .Bl -tag -width Fl
+ .It Em a=bytes
+ Set the attribute b-tree node size.
--- hfsprogs-332.14.orig/debian/patches/60-hfs-wrapper-boot-in-usr-share.diff
+++ hfsprogs-332.14/debian/patches/60-hfs-wrapper-boot-in-usr-share.diff
@@ -0,0 +1,13 @@
+Index: hfsprogs-332.14/newfs_hfs.tproj/makehfs.c
+===================================================================
+--- hfsprogs-332.14.orig/newfs_hfs.tproj/makehfs.c	2008-10-07 05:08:08.000000000 -0300
++++ hfsprogs-332.14/newfs_hfs.tproj/makehfs.c	2008-10-07 05:08:17.000000000 -0300
+@@ -70,7 +70,7 @@
+ #include "readme.h"
+ 
+ 
+-#define HFS_BOOT_DATA	"/usr/share/misc/hfsbootdata"
++#define HFS_BOOT_DATA	"/usr/share/hfsprogs/hfsbootdata"
+ 
+ #define HFS_JOURNAL_FILE	".journal"
+ #define HFS_JOURNAL_INFO	".journal_info_block"
--- hfsprogs-332.14.orig/debian/patches/20-apple_specific_files.patch
+++ hfsprogs-332.14/debian/patches/20-apple_specific_files.patch
@@ -0,0 +1,1007 @@
+Index: hfsprogs-332.14/include/bitstring.h
+===================================================================
+--- /dev/null	1970-01-01 00:00:00.000000000 +0000
++++ hfsprogs-332.14/include/bitstring.h	2008-10-07 05:08:10.000000000 -0300
+@@ -0,0 +1,164 @@
++/*
++ * Copyright (c) 2000 Apple Computer, Inc. All rights reserved.
++ *
++ * @APPLE_LICENSE_HEADER_START@
++ *
++ * The contents of this file constitute Original Code as defined in and
++ * are subject to the Apple Public Source License Version 1.1 (the
++ * "License").  You may not use this file except in compliance with the
++ * License.  Please obtain a copy of the License at
++ * http://www.apple.com/publicsource and read it before using this file.
++ *
++ * This Original Code and all software distributed under the License are
++ * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
++ * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
++ * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
++ * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
++ * License for the specific language governing rights and limitations
++ * under the License.
++ *
++ * @APPLE_LICENSE_HEADER_END@
++ */
++/*
++ * Copyright (c) 1989, 1993
++ *	The Regents of the University of California.  All rights reserved.
++ *
++ * This code is derived from software contributed to Berkeley by
++ * Paul Vixie.
++ *
++ * Redistribution and use in source and binary forms, with or without
++ * modification, are permitted provided that the following conditions
++ * are met:
++ * 1. Redistributions of source code must retain the above copyright
++ *    notice, this list of conditions and the following disclaimer.
++ * 2. Redistributions in binary form must reproduce the above copyright
++ *    notice, this list of conditions and the following disclaimer in the
++ *    documentation and/or other materials provided with the distribution.
++ * 3. All advertising materials mentioning features or use of this software
++ *    must display the following acknowledgement:
++ *	This product includes software developed by the University of
++ *	California, Berkeley and its contributors.
++ * 4. Neither the name of the University nor the names of its contributors
++ *    may be used to endorse or promote products derived from this software
++ *    without specific prior written permission.
++ *
++ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
++ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
++ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
++ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
++ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
++ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
++ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
++ * SUCH DAMAGE.
++ *
++ *	@(#)bitstring.h	8.1 (Berkeley) 7/19/93
++ */
++
++#ifndef _BITSTRING_H_
++#define	_BITSTRING_H_
++
++typedef	unsigned char bitstr_t;
++
++/* internal macros */
++				/* byte of the bitstring bit is in */
++#define	_bit_byte(bit) \
++	((bit) >> 3)
++
++				/* mask for the bit within its byte */
++#define	_bit_mask(bit) \
++	(1 << ((bit)&0x7))
++
++/* external macros */
++				/* bytes in a bitstring of nbits bits */
++#define	bitstr_size(nbits) \
++	((((nbits) - 1) >> 3) + 1)
++
++				/* allocate a bitstring */
++#define	bit_alloc(nbits) \
++	(bitstr_t *)calloc(1, \
++	    (unsigned int)bitstr_size(nbits) * sizeof(bitstr_t))
++
++				/* allocate a bitstring on the stack */
++#define	bit_decl(name, nbits) \
++	(name)[bitstr_size(nbits)]
++
++				/* is bit N of bitstring name set? */
++#define	bit_test(name, bit) \
++	((name)[_bit_byte(bit)] & _bit_mask(bit))
++
++				/* set bit N of bitstring name */
++#define	bit_set(name, bit) \
++	(name)[_bit_byte(bit)] |= _bit_mask(bit)
++
++				/* clear bit N of bitstring name */
++#define	bit_clear(name, bit) \
++	(name)[_bit_byte(bit)] &= ~_bit_mask(bit)
++
++				/* clear bits start ... stop in bitstring */
++#define	bit_nclear(name, start, stop) { \
++	register bitstr_t *_name = name; \
++	register int _start = start, _stop = stop; \
++	register int _startbyte = _bit_byte(_start); \
++	register int _stopbyte = _bit_byte(_stop); \
++	if (_startbyte == _stopbyte) { \
++		_name[_startbyte] &= ((0xff >> (8 - (_start&0x7))) | \
++				      (0xff << ((_stop&0x7) + 1))); \
++	} else { \
++		_name[_startbyte] &= 0xff >> (8 - (_start&0x7)); \
++		while (++_startbyte < _stopbyte) \
++			_name[_startbyte] = 0; \
++		_name[_stopbyte] &= 0xff << ((_stop&0x7) + 1); \
++	} \
++}
++
++				/* set bits start ... stop in bitstring */
++#define	bit_nset(name, start, stop) { \
++	register bitstr_t *_name = name; \
++	register int _start = start, _stop = stop; \
++	register int _startbyte = _bit_byte(_start); \
++	register int _stopbyte = _bit_byte(_stop); \
++	if (_startbyte == _stopbyte) { \
++		_name[_startbyte] |= ((0xff << (_start&0x7)) & \
++				    (0xff >> (7 - (_stop&0x7)))); \
++	} else { \
++		_name[_startbyte] |= 0xff << ((_start)&0x7); \
++		while (++_startbyte < _stopbyte) \
++	    		_name[_startbyte] = 0xff; \
++		_name[_stopbyte] |= 0xff >> (7 - (_stop&0x7)); \
++	} \
++}
++
++				/* find first bit clear in name */
++#define	bit_ffc(name, nbits, value) { \
++	register bitstr_t *_name = name; \
++	register int _byte, _nbits = nbits; \
++	register int _stopbyte = _bit_byte(_nbits), _value = -1; \
++	for (_byte = 0; _byte <= _stopbyte; ++_byte) \
++		if (_name[_byte] != 0xff) { \
++			_value = _byte << 3; \
++			for (_stopbyte = _name[_byte]; (_stopbyte&0x1); \
++			    ++_value, _stopbyte >>= 1); \
++			break; \
++		} \
++	*(value) = _value; \
++}
++
++				/* find first bit set in name */
++#define	bit_ffs(name, nbits, value) { \
++	register bitstr_t *_name = name; \
++	register int _byte, _nbits = nbits; \
++	register int _stopbyte = _bit_byte(_nbits), _value = -1; \
++	for (_byte = 0; _byte <= _stopbyte; ++_byte) \
++		if (_name[_byte]) { \
++			_value = _byte << 3; \
++			for (_stopbyte = _name[_byte]; !(_stopbyte&0x1); \
++			    ++_value, _stopbyte >>= 1); \
++			break; \
++		} \
++	*(value) = _value; \
++}
++
++#endif /* !_BITSTRING_H_ */
+Index: hfsprogs-332.14/include/hfs/hfs_format.h
+===================================================================
+--- /dev/null	1970-01-01 00:00:00.000000000 +0000
++++ hfsprogs-332.14/include/hfs/hfs_format.h	2008-10-07 05:08:10.000000000 -0300
+@@ -0,0 +1,689 @@
++/*
++ * Copyright (c) 2000-2004 Apple Computer, Inc. All rights reserved.
++ *
++ * @APPLE_LICENSE_HEADER_START@
++ *
++ * The contents of this file constitute Original Code as defined in and
++ * are subject to the Apple Public Source License Version 1.1 (the
++ * "License").  You may not use this file except in compliance with the
++ * License.  Please obtain a copy of the License at
++ * http://www.apple.com/publicsource and read it before using this file.
++ *
++ * This Original Code and all software distributed under the License are
++ * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
++ * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
++ * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
++ * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
++ * License for the specific language governing rights and limitations
++ * under the License.
++ *
++ * @APPLE_LICENSE_HEADER_END@
++ */
++#ifndef __HFS_FORMAT__
++#define __HFS_FORMAT__
++
++#include "missing.h"
++
++#include <sys/appleapiopts.h>
++
++/*
++ * hfs_format.c
++ *
++ * This file describes the on-disk format for HFS and HFS Plus volumes.
++ * The HFS Plus volume format is desciibed in detail in Apple Technote 1150.
++ *
++ * http://developer.apple.com/technotes/tn/tn1150.html
++ *
++ */
++
++#ifdef __cplusplus
++extern "C" {
++#endif
++
++/* some on-disk hfs structures have 68K alignment (misaligned) */
++
++#define PACKED_S	__attribute__((packed))
++
++/* Signatures used to differentiate between HFS and HFS Plus volumes */
++enum {
++	kHFSSigWord		= 0x4244,	/* 'BD' in ASCII */
++	kHFSPlusSigWord		= 0x482B,	/* 'H+' in ASCII */
++	kHFSXSigWord		= 0x4858,	/* 'HX' in ASCII */
++
++	kHFSPlusVersion		= 0x0004,	/* 'H+' volumes are version 4 only */
++	kHFSXVersion		= 0x0005,	/* 'HX' volumes start with version 5 */
++
++	kHFSPlusMountVersion	= 0x31302E30,	/* '10.0' for Mac OS X */
++	kHFSJMountVersion	= 0x4846534a,	/* 'HFSJ' for journaled HFS+ on OS X */
++	kFSKMountVersion	= 0x46534b21	/* 'FSK!' for failed journal replay */
++}PACKED_S;
++
++
++#ifdef __APPLE_API_PRIVATE
++/*
++ * Mac OS X has a special directory for linked and unlinked files (HFS Plus only).
++ * This directory and its contents are never exported from the filesystem under
++ * Mac OS X.
++ *
++ * To make this folder name sort last,  it has embedded null prefix.
++ * (0xC0, 0x80 in UTF-8)
++ */
++#define HFSPLUSMETADATAFOLDER  "\xC0\x80\xC0\x80\xC0\x80\xC0\x80HFS+ Private Data"
++
++/*
++ * Files in the HFS Private Data folder have one of the following prefixes
++ * followed by a decimal number (no leading zeros).  For indirect nodes this
++ * number is a 32 bit random number.  For unlinked (deleted) files that are
++ * still open, the number is the file ID for that file.
++ *
++ * e.g.  iNode7182000 and temp3296
++ */
++#define HFS_INODE_PREFIX	"iNode"
++#define HFS_DELETE_PREFIX	"temp"
++
++#endif /* __APPLE_API_PRIVATE */
++
++/*
++ * Indirect link files (hard links) have the following type/creator.
++ */
++enum {
++	kHardLinkFileType = 0x686C6E6B,  /* 'hlnk' */
++	kHFSPlusCreator   = 0x6866732B   /* 'hfs+' */
++}PACKED_S;
++
++
++#ifndef _HFSUNISTR255_DEFINED_
++#define _HFSUNISTR255_DEFINED_
++/* Unicode strings are used for HFS Plus file and folder names */
++struct HFSUniStr255 {
++	u_int16_t	length;		/* number of unicode characters */
++	u_int16_t	unicode[255];	/* unicode characters */
++} PACKED_S;
++typedef struct HFSUniStr255 HFSUniStr255;
++typedef const HFSUniStr255 *ConstHFSUniStr255Param;
++#endif /* _HFSUNISTR255_DEFINED_ */
++
++enum {
++	kHFSMaxVolumeNameChars		= 27,
++	kHFSMaxFileNameChars		= 31,
++	kHFSPlusMaxFileNameChars	= 255
++}PACKED_S;
++
++
++/* Extent overflow file data structures */
++
++/* HFS Extent key */
++struct HFSExtentKey {
++	u_int8_t 	keyLength;	/* length of key, excluding this field */
++	u_int8_t 	forkType;	/* 0 = data fork, FF = resource fork */
++	u_int32_t 	fileID;		/* file ID */
++	u_int16_t 	startBlock;	/* first file allocation block number in this extent */
++}PACKED_S;
++typedef struct HFSExtentKey HFSExtentKey;
++
++/* HFS Plus Extent key */
++struct HFSPlusExtentKey {
++	u_int16_t 	keyLength;		/* length of key, excluding this field */
++	u_int8_t 	forkType;		/* 0 = data fork, FF = resource fork */
++	u_int8_t 	pad;			/* make the other fields align on 32-bit boundary */
++	u_int32_t 	fileID;			/* file ID */
++	u_int32_t 	startBlock;		/* first file allocation block number in this extent */
++}PACKED_S;
++typedef struct HFSPlusExtentKey HFSPlusExtentKey;
++
++/* Number of extent descriptors per extent record */
++enum {
++	kHFSExtentDensity	= 3,
++	kHFSPlusExtentDensity	= 8
++}PACKED_S;
++
++/* HFS extent descriptor */
++struct HFSExtentDescriptor {
++	u_int16_t 	startBlock;		/* first allocation block */
++	u_int16_t 	blockCount;		/* number of allocation blocks */
++}PACKED_S;
++typedef struct HFSExtentDescriptor HFSExtentDescriptor;
++
++/* HFS Plus extent descriptor */
++struct HFSPlusExtentDescriptor {
++	u_int32_t 	startBlock;		/* first allocation block */
++	u_int32_t 	blockCount;		/* number of allocation blocks */
++}PACKED_S;
++typedef struct HFSPlusExtentDescriptor HFSPlusExtentDescriptor;
++
++/* HFS extent record */
++typedef HFSExtentDescriptor HFSExtentRecord[3];
++
++/* HFS Plus extent record */
++typedef HFSPlusExtentDescriptor HFSPlusExtentRecord[8];
++
++
++/* Finder information */
++struct FndrFileInfo {
++	u_int32_t 	fdType;		/* file type */
++	u_int32_t 	fdCreator;	/* file creator */
++	u_int16_t 	fdFlags;	/* Finder flags */
++	struct {
++	    int16_t	v;		/* file's location */
++	    int16_t	h;
++	} PACKED_S fdLocation;
++	int16_t 	opaque;
++}PACKED_S;
++typedef struct FndrFileInfo FndrFileInfo;
++
++struct FndrDirInfo {
++	struct {			/* folder's window rectangle */
++	    int16_t	top;
++	    int16_t	left;
++	    int16_t	bottom;
++	    int16_t	right;
++	}PACKED_S frRect;
++	unsigned short 	frFlags;	/* Finder flags */
++	struct {
++	    u_int16_t	v;		/* folder's location */
++	    u_int16_t	h;
++	}PACKED_S frLocation;
++	int16_t 	opaque;
++}PACKED_S;
++typedef struct FndrDirInfo FndrDirInfo;
++
++struct FndrOpaqueInfo {
++	int8_t opaque[16];
++}PACKED_S;
++typedef struct FndrOpaqueInfo FndrOpaqueInfo;
++
++
++/* HFS Plus Fork data info - 80 bytes */
++struct HFSPlusForkData {
++	u_int64_t 		logicalSize;	/* fork's logical size in bytes */
++	u_int32_t 		clumpSize;	/* fork's clump size in bytes */
++	u_int32_t 		totalBlocks;	/* total blocks used by this fork */
++	HFSPlusExtentRecord 	extents;	/* initial set of extents */
++}PACKED_S;
++typedef struct HFSPlusForkData HFSPlusForkData;
++
++
++/* Mac OS X has 16 bytes worth of "BSD" info.
++ *
++ * Note:  Mac OS 9 implementations and applications
++ * should preserve, but not change, this information.
++ */
++struct HFSPlusBSDInfo {
++	u_int32_t 	ownerID;	/* user or group ID of file/folder owner */
++	u_int32_t 	groupID;	/* additional user of group ID */
++	u_int8_t 	adminFlags;	/* super-user changeable flags */
++	u_int8_t 	ownerFlags;	/* owner changeable flags */
++	u_int16_t 	fileMode;	/* file type and permission bits */
++	union {
++	    u_int32_t	iNodeNum;	/* indirect node number (hard links only) */
++	    u_int32_t	linkCount;	/* links that refer to this indirect node */
++	    u_int32_t	rawDevice;	/* special file device (FBLK and FCHR only) */
++	}PACKED_S special;
++}PACKED_S;
++typedef struct HFSPlusBSDInfo HFSPlusBSDInfo;
++
++
++/* Catalog file data structures */
++
++enum {
++	kHFSRootParentID		= 1,	/* Parent ID of the root folder */
++	kHFSRootFolderID		= 2,	/* Folder ID of the root folder */
++	kHFSExtentsFileID		= 3,	/* File ID of the extents file */
++	kHFSCatalogFileID		= 4,	/* File ID of the catalog file */
++	kHFSBadBlockFileID		= 5,	/* File ID of the bad allocation block file */
++	kHFSAllocationFileID		= 6,	/* File ID of the allocation file (HFS Plus only) */
++	kHFSStartupFileID		= 7,	/* File ID of the startup file (HFS Plus only) */
++	kHFSAttributesFileID		= 8,	/* File ID of the attribute file (HFS Plus only) */
++	kHFSRepairCatalogFileID		= 14,	/* Used when rebuilding Catalog B-tree */
++	kHFSBogusExtentFileID		= 15,	/* Used for exchanging extents in extents file */
++	kHFSFirstUserCatalogNodeID	= 16
++}PACKED_S;
++
++/* HFS catalog key */
++struct HFSCatalogKey {
++	u_int8_t 	keyLength;		/* key length (in bytes) */
++	u_int8_t 	reserved;		/* reserved (set to zero) */
++	u_int32_t 	parentID;		/* parent folder ID */
++	u_int8_t 	nodeName[kHFSMaxFileNameChars + 1]; /* catalog node name */
++}PACKED_S;
++typedef struct HFSCatalogKey HFSCatalogKey;
++
++/* HFS Plus catalog key */
++struct HFSPlusCatalogKey {
++	u_int16_t 		keyLength;	/* key length (in bytes) */
++	u_int32_t 		parentID;	/* parent folder ID */
++	HFSUniStr255 		nodeName;	/* catalog node name */
++}PACKED_S;
++typedef struct HFSPlusCatalogKey HFSPlusCatalogKey;
++
++/* Catalog record types */
++enum {
++	/* HFS Catalog Records */
++	kHFSFolderRecord		= 0x0100,	/* Folder record */
++	kHFSFileRecord			= 0x0200,	/* File record */
++	kHFSFolderThreadRecord		= 0x0300,	/* Folder thread record */
++	kHFSFileThreadRecord		= 0x0400,	/* File thread record */
++
++	/* HFS Plus Catalog Records */
++	kHFSPlusFolderRecord		= 1,		/* Folder record */
++	kHFSPlusFileRecord		= 2,		/* File record */
++	kHFSPlusFolderThreadRecord	= 3,		/* Folder thread record */
++	kHFSPlusFileThreadRecord	= 4		/* File thread record */
++}PACKED_S;
++
++
++/* Catalog file record flags */
++enum {
++	kHFSFileLockedBit	= 0x0000,	/* file is locked and cannot be written to */
++	kHFSFileLockedMask	= 0x0001,
++
++	kHFSThreadExistsBit	= 0x0001,	/* a file thread record exists for this file */
++	kHFSThreadExistsMask	= 0x0002,
++
++	kHFSHasAttributesBit	= 0x0002,	/* object has extended attributes */
++	kHFSHasAttributesMask	= 0x0004,
++
++	kHFSHasSecurityBit	= 0x0003,	/* object has security data (ACLs) */
++	kHFSHasSecurityMask	= 0x0008
++}PACKED_S;
++
++
++/* HFS catalog folder record - 70 bytes */
++struct HFSCatalogFolder {
++	int16_t 		recordType;		/* == kHFSFolderRecord */
++	u_int16_t 		flags;			/* folder flags */
++	u_int16_t 		valence;		/* folder valence */
++	u_int32_t		folderID;		/* folder ID */
++	u_int32_t 		createDate;		/* date and time of creation */
++	u_int32_t 		modifyDate;		/* date and time of last modification */
++	u_int32_t 		backupDate;		/* date and time of last backup */
++	FndrDirInfo 		userInfo;		/* Finder information */
++	FndrOpaqueInfo		finderInfo;		/* additional Finder information */
++	u_int32_t 		reserved[4];		/* reserved - initialized as zero */
++}PACKED_S;
++typedef struct HFSCatalogFolder HFSCatalogFolder;
++
++/* HFS Plus catalog folder record - 88 bytes */
++struct HFSPlusCatalogFolder {
++	int16_t 		recordType;		/* == kHFSPlusFolderRecord */
++	u_int16_t 		flags;			/* file flags */
++	u_int32_t 		valence;		/* folder's valence (limited to 2^16 in Mac OS) */
++	u_int32_t 		folderID;		/* folder ID */
++	u_int32_t 		createDate;		/* date and time of creation */
++	u_int32_t 		contentModDate;		/* date and time of last content modification */
++	u_int32_t 		attributeModDate;	/* date and time of last attribute modification */
++	u_int32_t 		accessDate;		/* date and time of last access (MacOS X only) */
++	u_int32_t 		backupDate;		/* date and time of last backup */
++	HFSPlusBSDInfo		bsdInfo;		/* permissions (for MacOS X) */
++	FndrDirInfo 		userInfo;		/* Finder information */
++	FndrOpaqueInfo	 	finderInfo;		/* additional Finder information */
++	u_int32_t 		textEncoding;		/* hint for name conversions */
++	u_int32_t 		attrBlocks;		/* cached count of attribute data blocks */
++}PACKED_S;
++typedef struct HFSPlusCatalogFolder HFSPlusCatalogFolder;
++
++/* HFS catalog file record - 102 bytes */
++struct HFSCatalogFile {
++	int16_t 		recordType;		/* == kHFSFileRecord */
++	u_int8_t 		flags;			/* file flags */
++	int8_t 			fileType;		/* file type (unused ?) */
++	FndrFileInfo 		userInfo;		/* Finder information */
++	u_int32_t 		fileID;			/* file ID */
++	u_int16_t 		dataStartBlock;		/* not used - set to zero */
++	int32_t 		dataLogicalSize;	/* logical EOF of data fork */
++	int32_t 		dataPhysicalSize;	/* physical EOF of data fork */
++	u_int16_t		rsrcStartBlock;		/* not used - set to zero */
++	int32_t			rsrcLogicalSize;	/* logical EOF of resource fork */
++	int32_t			rsrcPhysicalSize;	/* physical EOF of resource fork */
++	u_int32_t		createDate;		/* date and time of creation */
++	u_int32_t		modifyDate;		/* date and time of last modification */
++	u_int32_t		backupDate;		/* date and time of last backup */
++	FndrOpaqueInfo		finderInfo;		/* additional Finder information */
++	u_int16_t		clumpSize;		/* file clump size (not used) */
++	HFSExtentRecord		dataExtents;		/* first data fork extent record */
++	HFSExtentRecord		rsrcExtents;		/* first resource fork extent record */
++	u_int32_t		reserved;		/* reserved - initialized as zero */
++}PACKED_S;
++typedef struct HFSCatalogFile HFSCatalogFile;
++
++/* HFS Plus catalog file record - 248 bytes */
++struct HFSPlusCatalogFile {
++	int16_t 		recordType;		/* == kHFSPlusFileRecord */
++	u_int16_t 		flags;			/* file flags */
++	u_int32_t 		reserved1;		/* reserved - initialized as zero */
++	u_int32_t 		fileID;			/* file ID */
++	u_int32_t 		createDate;		/* date and time of creation */
++	u_int32_t 		contentModDate;		/* date and time of last content modification */
++	u_int32_t 		attributeModDate;	/* date and time of last attribute modification */
++	u_int32_t 		accessDate;		/* date and time of last access (MacOS X only) */
++	u_int32_t 		backupDate;		/* date and time of last backup */
++	HFSPlusBSDInfo 		bsdInfo;		/* permissions (for MacOS X) */
++	FndrFileInfo 		userInfo;		/* Finder information */
++	FndrOpaqueInfo	 	finderInfo;		/* additional Finder information */
++	u_int32_t 		textEncoding;		/* hint for name conversions */
++	u_int32_t 		attrBlocks;		/* cached count of attribute data blocks */
++
++	/* Note: these start on double long (64 bit) boundry */
++	HFSPlusForkData 	dataFork;		/* size and block data for data fork */
++	HFSPlusForkData 	resourceFork;		/* size and block data for resource fork */
++}PACKED_S;
++typedef struct HFSPlusCatalogFile HFSPlusCatalogFile;
++
++/* HFS catalog thread record - 46 bytes */
++struct HFSCatalogThread {
++	int16_t 	recordType;		/* == kHFSFolderThreadRecord or kHFSFileThreadRecord */
++	int32_t 	reserved[2];		/* reserved - initialized as zero */
++	u_int32_t 	parentID;		/* parent ID for this catalog node */
++	u_int8_t 	nodeName[kHFSMaxFileNameChars + 1]; /* name of this catalog node */
++}PACKED_S;
++typedef struct HFSCatalogThread HFSCatalogThread;
++
++/* HFS Plus catalog thread record -- 264 bytes */
++struct HFSPlusCatalogThread {
++	int16_t 	recordType;		/* == kHFSPlusFolderThreadRecord or kHFSPlusFileThreadRecord */
++	int16_t 	reserved;		/* reserved - initialized as zero */
++	u_int32_t 	parentID;		/* parent ID for this catalog node */
++	HFSUniStr255 	nodeName;		/* name of this catalog node (variable length) */
++}PACKED_S;
++typedef struct HFSPlusCatalogThread HFSPlusCatalogThread;
++
++#ifdef __APPLE_API_UNSTABLE
++/*
++  	These are the types of records in the attribute B-tree.  The values were
++  	chosen so that they wouldn't conflict with the catalog record types.
++*/
++enum {
++	kHFSPlusAttrInlineData	= 0x10,    /* if size <  kAttrOverflowSize */
++	kHFSPlusAttrForkData	= 0x20,    /* if size >= kAttrOverflowSize */
++	kHFSPlusAttrExtents	= 0x30     /* overflow extents for large attributes */
++}PACKED_S;
++
++
++/*
++  	HFSPlusAttrForkData
++  	For larger attributes, whose value is stored in allocation blocks.
++  	If the attribute has more than 8 extents, there will be additonal
++  	records (of type HFSPlusAttrExtents) for this attribute.
++*/
++struct HFSPlusAttrForkData {
++	u_int32_t 	recordType;		/* == kHFSPlusAttrForkData*/
++	u_int32_t 	reserved;
++	HFSPlusForkData theFork;		/* size and first extents of value*/
++}PACKED_S;
++typedef struct HFSPlusAttrForkData HFSPlusAttrForkData;
++
++/*
++  	HFSPlusAttrExtents
++  	This record contains information about overflow extents for large,
++  	fragmented attributes.
++*/
++struct HFSPlusAttrExtents {
++	u_int32_t 		recordType;	/* == kHFSPlusAttrExtents*/
++	u_int32_t 		reserved;
++	HFSPlusExtentRecord	extents;	/* additional extents*/
++}PACKED_S;
++typedef struct HFSPlusAttrExtents HFSPlusAttrExtents;
++
++/*
++ * Atrributes B-tree Data Record
++ *
++ * For small attributes, whose entire value is stored
++ * within a single B-tree record.
++ */
++struct HFSPlusAttrData {
++	u_int32_t    recordType;   /* == kHFSPlusAttrInlineData */
++	u_int32_t    reserved[2];
++	u_int32_t    attrSize;     /* size of attribute data in bytes */
++	u_int8_t     attrData[2];  /* variable length */
++}PACKED_S;
++typedef struct HFSPlusAttrData HFSPlusAttrData;
++
++
++/* HFSPlusAttrInlineData is obsolete use HFSPlusAttrData instead */
++struct HFSPlusAttrInlineData {
++	u_int32_t 	recordType;
++	u_int32_t 	reserved;
++	u_int32_t 	logicalSize;
++	u_int8_t 	userData[2];
++}PACKED_S;
++typedef struct HFSPlusAttrInlineData HFSPlusAttrInlineData;
++
++
++/*	A generic Attribute Record*/
++union HFSPlusAttrRecord {
++	u_int32_t 		recordType;
++	HFSPlusAttrInlineData 	inlineData;   /* NOT USED */
++	HFSPlusAttrData 	attrData;
++	HFSPlusAttrForkData 	forkData;
++	HFSPlusAttrExtents 	overflowExtents;
++}PACKED_S;
++typedef union HFSPlusAttrRecord HFSPlusAttrRecord;
++
++/* Attribute key */
++enum { kHFSMaxAttrNameLen = 127 };
++struct HFSPlusAttrKey {
++	u_int16_t     keyLength;       /* key length (in bytes) */
++	u_int16_t     pad;	       /* set to zero */
++	u_int32_t     fileID;          /* file associated with attribute */
++	u_int32_t     startBlock;      /* first attribue allocation block number for extents */
++	u_int16_t     attrNameLen;     /* number of unicode characters */
++	u_int16_t     attrName[127];   /* attribute name (Unicode) */
++}PACKED_S;
++typedef struct HFSPlusAttrKey HFSPlusAttrKey;
++
++#define kHFSPlusAttrKeyMaximumLength   (sizeof(HFSPlusAttrKey) - sizeof(u_int16_t))
++#define kHFSPlusAttrKeyMinimumLength   (kHFSPlusAttrKeyMaximumLength - (127 * sizeof(u_int16_t)))
++
++#endif /* __APPLE_API_UNSTABLE */
++
++
++/* Key and node lengths */
++enum {
++	kHFSPlusExtentKeyMaximumLength = sizeof(HFSPlusExtentKey) - sizeof(u_int16_t),
++	kHFSExtentKeyMaximumLength	= sizeof(HFSExtentKey) - sizeof(u_int8_t),
++	kHFSPlusCatalogKeyMaximumLength = sizeof(HFSPlusCatalogKey) - sizeof(u_int16_t),
++	kHFSPlusCatalogKeyMinimumLength = kHFSPlusCatalogKeyMaximumLength - sizeof(HFSUniStr255) + sizeof(u_int16_t),
++	kHFSCatalogKeyMaximumLength	= sizeof(HFSCatalogKey) - sizeof(u_int8_t),
++	kHFSCatalogKeyMinimumLength	= kHFSCatalogKeyMaximumLength - (kHFSMaxFileNameChars + 1) + sizeof(u_int8_t),
++	kHFSPlusCatalogMinNodeSize	= 4096,
++	kHFSPlusExtentMinNodeSize	= 512,
++	kHFSPlusAttrMinNodeSize		= 4096
++}PACKED_S;
++
++/* HFS and HFS Plus volume attribute bits */
++enum {
++							/* Bits 0-6 are reserved (always cleared by MountVol call) */
++	kHFSVolumeHardwareLockBit	= 7,		/* volume is locked by hardware */
++	kHFSVolumeUnmountedBit		= 8,		/* volume was successfully unmounted */
++	kHFSVolumeSparedBlocksBit	= 9,		/* volume has bad blocks spared */
++	kHFSVolumeNoCacheRequiredBit = 10,		/* don't cache volume blocks (i.e. RAM or ROM disk) */
++	kHFSBootVolumeInconsistentBit = 11,		/* boot volume is inconsistent (System 7.6 and later) */
++	kHFSCatalogNodeIDsReusedBit = 12,
++	kHFSVolumeJournaledBit = 13,			/* this volume has a journal on it */
++	kHFSVolumeInconsistentBit = 14,			/* serious inconsistencies detected at runtime */
++	kHFSVolumeSoftwareLockBit	= 15,		/* volume is locked by software */
++
++	kHFSVolumeHardwareLockMask	= 1 << kHFSVolumeHardwareLockBit,
++	kHFSVolumeUnmountedMask		= 1 << kHFSVolumeUnmountedBit,
++	kHFSVolumeSparedBlocksMask	= 1 << kHFSVolumeSparedBlocksBit,
++	kHFSVolumeNoCacheRequiredMask = 1 << kHFSVolumeNoCacheRequiredBit,
++	kHFSBootVolumeInconsistentMask = 1 << kHFSBootVolumeInconsistentBit,
++	kHFSCatalogNodeIDsReusedMask = 1 << kHFSCatalogNodeIDsReusedBit,
++	kHFSVolumeJournaledMask	= 1 << kHFSVolumeJournaledBit,
++	kHFSVolumeInconsistentMask = 1 << kHFSVolumeInconsistentBit,
++	kHFSVolumeSoftwareLockMask	= 1 << kHFSVolumeSoftwareLockBit,
++	kHFSMDBAttributesMask		= 0x8380
++}PACKED_S;
++
++
++/* HFS Master Directory Block - 162 bytes */
++/* Stored at sector #2 (3rd sector) and second-to-last sector. */
++struct HFSMasterDirectoryBlock {
++	u_int16_t 		drSigWord;	/* == kHFSSigWord */
++	u_int32_t 		drCrDate;	/* date and time of volume creation */
++	u_int32_t 		drLsMod;	/* date and time of last modification */
++	u_int16_t 		drAtrb;		/* volume attributes */
++	u_int16_t 		drNmFls;	/* number of files in root folder */
++	u_int16_t 		drVBMSt;	/* first block of volume bitmap */
++	u_int16_t 		drAllocPtr;	/* start of next allocation search */
++	u_int16_t 		drNmAlBlks;	/* number of allocation blocks in volume */
++	u_int32_t 		drAlBlkSiz;	/* size (in bytes) of allocation blocks */
++	u_int32_t 		drClpSiz;	/* default clump size */
++	u_int16_t 		drAlBlSt;	/* first allocation block in volume */
++	u_int32_t 		drNxtCNID;	/* next unused catalog node ID */
++	u_int16_t 		drFreeBks;	/* number of unused allocation blocks */
++	u_int8_t 		drVN[kHFSMaxVolumeNameChars + 1];  /* volume name */
++	u_int32_t 		drVolBkUp;	/* date and time of last backup */
++	u_int16_t 		drVSeqNum;	/* volume backup sequence number */
++	u_int32_t 		drWrCnt;	/* volume write count */
++	u_int32_t 		drXTClpSiz;	/* clump size for extents overflow file */
++	u_int32_t 		drCTClpSiz;	/* clump size for catalog file */
++	u_int16_t 		drNmRtDirs;	/* number of directories in root folder */
++	u_int32_t 		drFilCnt;	/* number of files in volume */
++	u_int32_t 		drDirCnt;	/* number of directories in volume */
++	u_int32_t 		drFndrInfo[8];	/* information used by the Finder */
++	u_int16_t 		drEmbedSigWord;	/* embedded volume signature (formerly drVCSize) */
++	HFSExtentDescriptor	drEmbedExtent;	/* embedded volume location and size (formerly drVBMCSize and drCtlCSize) */
++	u_int32_t		drXTFlSize;	/* size of extents overflow file */
++	HFSExtentRecord		drXTExtRec;	/* extent record for extents overflow file */
++	u_int32_t 		drCTFlSize;	/* size of catalog file */
++	HFSExtentRecord 	drCTExtRec;	/* extent record for catalog file */
++}PACKED_S;
++typedef struct HFSMasterDirectoryBlock	HFSMasterDirectoryBlock;
++
++
++#ifdef __APPLE_API_UNSTABLE
++#define SET_HFS_TEXT_ENCODING(hint)  \
++	(0x656e6300 | ((hint) & 0xff))
++#define GET_HFS_TEXT_ENCODING(hint)  \
++	(((hint) & 0xffffff00) == 0x656e6300 ? (hint) & 0x000000ff : 0xffffffffU)
++#endif /* __APPLE_API_UNSTABLE */
++
++
++/* HFS Plus Volume Header - 512 bytes */
++/* Stored at sector #2 (3rd sector) and second-to-last sector. */
++struct HFSPlusVolumeHeader {
++	u_int16_t 	signature;		/* == kHFSPlusSigWord */
++	u_int16_t 	version;		/* == kHFSPlusVersion */
++	u_int32_t 	attributes;		/* volume attributes */
++	u_int32_t 	lastMountedVersion;	/* implementation version which last mounted volume */
++	u_int32_t 	journalInfoBlock;	/* block addr of journal info (if volume is journaled, zero otherwise) */
++
++	u_int32_t 	createDate;		/* date and time of volume creation */
++	u_int32_t 	modifyDate;		/* date and time of last modification */
++	u_int32_t 	backupDate;		/* date and time of last backup */
++	u_int32_t 	checkedDate;		/* date and time of last disk check */
++
++	u_int32_t 	fileCount;		/* number of files in volume */
++	u_int32_t 	folderCount;		/* number of directories in volume */
++
++	u_int32_t 	blockSize;		/* size (in bytes) of allocation blocks */
++	u_int32_t 	totalBlocks;		/* number of allocation blocks in volume (includes this header and VBM*/
++	u_int32_t 	freeBlocks;		/* number of unused allocation blocks */
++
++	u_int32_t 	nextAllocation;		/* start of next allocation search */
++	u_int32_t 	rsrcClumpSize;		/* default resource fork clump size */
++	u_int32_t 	dataClumpSize;		/* default data fork clump size */
++	u_int32_t 	nextCatalogID;		/* next unused catalog node ID */
++
++	u_int32_t 	writeCount;		/* volume write count */
++	u_int64_t 	encodingsBitmap;	/* which encodings have been use  on this volume */
++
++	u_int8_t 	finderInfo[32];		/* information used by the Finder */
++
++	HFSPlusForkData	 allocationFile;	/* allocation bitmap file */
++	HFSPlusForkData  extentsFile;		/* extents B-tree file */
++	HFSPlusForkData  catalogFile;		/* catalog B-tree file */
++	HFSPlusForkData  attributesFile;	/* extended attributes B-tree file */
++	HFSPlusForkData	 startupFile;		/* boot file (secondary loader) */
++}PACKED_S;
++typedef struct HFSPlusVolumeHeader HFSPlusVolumeHeader;
++
++
++/* B-tree structures */
++
++enum BTreeKeyLimits{
++	kMaxKeyLength	= 520
++}PACKED_S;
++
++union BTreeKey{
++	u_int8_t	length8;
++	u_int16_t	length16;
++	u_int8_t	rawData [kMaxKeyLength+2];
++}PACKED_S;
++typedef union BTreeKey BTreeKey;
++
++/* BTNodeDescriptor -- Every B-tree node starts with these fields. */
++struct BTNodeDescriptor {
++	u_int32_t	fLink;			/* next node at this level*/
++	u_int32_t 	bLink;			/* previous node at this level*/
++	int8_t 		kind;			/* kind of node (leaf, index, header, map)*/
++	u_int8_t 	height;			/* zero for header, map; child is one more than parent*/
++	u_int16_t 	numRecords;		/* number of records in this node*/
++	u_int16_t 	reserved;		/* reserved - initialized as zero */
++}PACKED_S;
++typedef struct BTNodeDescriptor BTNodeDescriptor;
++
++/* Constants for BTNodeDescriptor kind */
++enum {
++	kBTLeafNode	= -1,
++	kBTIndexNode	= 0,
++	kBTHeaderNode	= 1,
++	kBTMapNode	= 2
++}PACKED_S;
++
++/* BTHeaderRec -- The first record of a B-tree header node */
++struct BTHeaderRec {
++	u_int16_t	treeDepth;		/* maximum height (usually leaf nodes) */
++	u_int32_t 	rootNode;		/* node number of root node */
++	u_int32_t 	leafRecords;		/* number of leaf records in all leaf nodes */
++	u_int32_t 	firstLeafNode;		/* node number of first leaf node */
++	u_int32_t 	lastLeafNode;		/* node number of last leaf node */
++	u_int16_t 	nodeSize;		/* size of a node, in bytes */
++	u_int16_t 	maxKeyLength;		/* reserved */
++	u_int32_t 	totalNodes;		/* total number of nodes in tree */
++	u_int32_t 	freeNodes;		/* number of unused (free) nodes in tree */
++	u_int16_t 	reserved1;		/* unused */
++	u_int32_t 	clumpSize;		/* reserved */
++	u_int8_t 	btreeType;		/* reserved */
++	u_int8_t 	keyCompareType;		/* Key string Comparison Type */
++	u_int32_t 	attributes;		/* persistent attributes about the tree */
++	u_int32_t 	reserved3[16];		/* reserved */
++}PACKED_S;
++typedef struct BTHeaderRec BTHeaderRec;
++
++/* Constants for BTHeaderRec attributes */
++enum {
++	kBTBadCloseMask		 = 0x00000001,	/* reserved */
++	kBTBigKeysMask		 = 0x00000002,	/* key length field is 16 bits */
++	kBTVariableIndexKeysMask = 0x00000004	/* keys in index nodes are variable length */
++}PACKED_S;
++
++
++/* Catalog Key Name Comparison Type */
++enum {
++	kHFSCaseFolding   = 0xCF,  /* case folding (case-insensitive) */
++	kHFSBinaryCompare = 0xBC  /* binary compare (case-sensitive) */
++}PACKED_S;
++
++/* JournalInfoBlock - Structure that describes where our journal lives */
++struct JournalInfoBlock {
++	u_int32_t	flags;
++    	u_int32_t       device_signature[8];  // signature used to locate our device.
++	u_int64_t       offset;               // byte offset to the journal on the device
++	u_int64_t       size;                 // size in bytes of the journal
++	u_int32_t 	reserved[32];
++}PACKED_S;
++typedef struct JournalInfoBlock JournalInfoBlock;
++
++enum {
++    kJIJournalInFSMask          = 0x00000001,
++    kJIJournalOnOtherDeviceMask = 0x00000002,
++    kJIJournalNeedInitMask      = 0x00000004
++}PACKED_S;
++
++#ifdef __cplusplus
++}
++#endif
++
++#endif /* __HFS_FORMAT__ */
+Index: hfsprogs-332.14/include/hfs/hfs_mount.h
+===================================================================
+--- /dev/null	1970-01-01 00:00:00.000000000 +0000
++++ hfsprogs-332.14/include/hfs/hfs_mount.h	2008-10-07 05:08:10.000000000 -0300
+@@ -0,0 +1,78 @@
++/*
++ * Copyright (c) 2000-2003 Apple Computer, Inc. All rights reserved.
++ *
++ * @APPLE_LICENSE_HEADER_START@
++ *
++ * The contents of this file constitute Original Code as defined in and
++ * are subject to the Apple Public Source License Version 1.1 (the
++ * "License").  You may not use this file except in compliance with the
++ * License.  Please obtain a copy of the License at
++ * http://www.apple.com/publicsource and read it before using this file.
++ *
++ * This Original Code and all software distributed under the License are
++ * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
++ * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
++ * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
++ * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
++ * License for the specific language governing rights and limitations
++ * under the License.
++ *
++ * @APPLE_LICENSE_HEADER_END@
++ */
++/*
++ * Copyright (c) 1997-2002 Apple Computer, Inc. All Rights Reserved
++ *
++ */
++
++#ifndef _HFS_MOUNT_H_
++#define _HFS_MOUNT_H_
++
++#include <sys/appleapiopts.h>
++
++#include <sys/mount.h>
++#include <sys/time.h>
++
++/*
++ * Arguments to mount HFS-based filesystems
++ */
++
++#define OVERRIDE_UNKNOWN_PERMISSIONS 0
++
++#define UNKNOWNUID ((uid_t)99)
++#define UNKNOWNGID ((gid_t)99)
++#define UNKNOWNPERMISSIONS (S_IRWXU | S_IROTH | S_IXOTH)		/* 705 */
++
++#ifdef __APPLE_API_UNSTABLE
++struct hfs_mount_args {
++#ifndef KERNEL
++	char	*fspec;			/* block special device to mount */
++#endif
++	uid_t	hfs_uid;		/* uid that owns hfs files (standard HFS only) */
++	gid_t	hfs_gid;		/* gid that owns hfs files (standard HFS only) */
++	mode_t	hfs_mask;		/* mask to be applied for hfs perms  (standard HFS only) */
++	u_int32_t hfs_encoding;		/* encoding for this volume (standard HFS only) */
++	struct	timezone hfs_timezone;	/* user time zone info (standard HFS only) */
++	int		flags;			/* mounting flags, see below */
++	int     journal_tbuffer_size;   /* size in bytes of the journal transaction buffer */
++	int		journal_flags;          /* flags to pass to journal_open/create */
++	int		journal_disable;        /* don't use journaling (potentially dangerous) */
++};
++
++#define HFSFSMNT_NOXONFILES	0x1	/* disable execute permissions for files */
++#define HFSFSMNT_WRAPPER	0x2	/* mount HFS wrapper (if it exists) */
++#define HFSFSMNT_EXTENDED_ARGS  0x4     /* indicates new fields after "flags" are valid */
++
++/*
++ * Sysctl values for HFS
++ */
++#define HFS_ENCODINGBIAS	1	    /* encoding matching CJK bias */
++#define HFS_EXTEND_FS		2
++#define HFS_ENCODINGHINT	3	    /* guess encoding for string */
++#define HFS_ENABLE_JOURNALING   0x082969
++#define HFS_DISABLE_JOURNALING  0x031272
++#define HFS_GET_JOURNAL_INFO    0x6a6e6c69
++#define HFS_SET_PKG_EXTENSIONS  0x121031
++
++#endif /* __APPLE_API_UNSTABLE */
++
++#endif /* ! _HFS_MOUNT_H_ */
+Index: hfsprogs-332.14/include/sys/appleapiopts.h
+===================================================================
+--- /dev/null	1970-01-01 00:00:00.000000000 +0000
++++ hfsprogs-332.14/include/sys/appleapiopts.h	2008-10-07 05:08:10.000000000 -0300
+@@ -0,0 +1,56 @@
++/*
++ * Copyright (c) 2002 Apple Computer, Inc. All rights reserved.
++ *
++ * @APPLE_LICENSE_HEADER_START@
++ *
++ * The contents of this file constitute Original Code as defined in and
++ * are subject to the Apple Public Source License Version 1.1 (the
++ * "License").  You may not use this file except in compliance with the
++ * License.  Please obtain a copy of the License at
++ * http://www.apple.com/publicsource and read it before using this file.
++ *
++ * This Original Code and all software distributed under the License are
++ * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
++ * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
++ * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
++ * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
++ * License for the specific language governing rights and limitations
++ * under the License.
++ *
++ * @APPLE_LICENSE_HEADER_END@
++ */
++
++#ifndef __SYS_APPLEAPIOPTS_H__
++#define __SYS_APPLEAPIOPTS_H__
++
++
++#ifndef __APPLE_API_STANDARD
++#define __APPLE_API_STANDARD
++#endif /* __APPLE_API_STANDARD */
++
++#ifndef __APPLE_API_STABLE
++#define __APPLE_API_STABLE
++#endif /* __APPLE_API_STABLE */
++
++#ifndef __APPLE_API_STRICT_CONFORMANCE
++
++#ifndef __APPLE_API_EVOLVING
++#define __APPLE_API_EVOLVING
++#endif /* __APPLE_API_EVOLVING */
++
++#ifndef __APPLE_API_UNSTABLE
++#define __APPLE_API_UNSTABLE
++#endif /* __APPLE_API_UNSTABLE */
++
++#ifndef __APPLE_API_PRIVATE
++#define __APPLE_API_PRIVATE
++#endif /* __APPLE_API_PRIVATE */
++
++#ifndef __APPLE_API_OBSOLETE
++#define __APPLE_API_OBSOLETE
++#endif /* __APPLE_API_OBSOLETE */
++
++#endif /* __APPLE_API_STRICT_CONFORMANCE */
++
++#endif /* __SYS_APPLEAPIOPTS_H__ */
++
